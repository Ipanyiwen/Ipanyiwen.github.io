<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pan</title>
  
  <subtitle>读书随处净土，闭门即是深山.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ipanyiwen.github.io/"/>
  <updated>2018-11-23T18:56:12.965Z</updated>
  <id>https://ipanyiwen.github.io/</id>
  
  <author>
    <name>Pan yiwen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>浅析tomcat原理</title>
    <link href="https://ipanyiwen.github.io/2018/11/24/%E6%B5%85%E6%9E%90tomcat%E5%8E%9F%E7%90%86/"/>
    <id>https://ipanyiwen.github.io/2018/11/24/浅析tomcat原理/</id>
    <published>2018-11-23T18:56:12.965Z</published>
    <updated>2018-11-23T18:56:12.965Z</updated>
    
    <content type="html"><![CDATA[<p>上上个星期，看了一下how tomcat works这本书，今天捡起来看一会，发现忘得有点快，特地写点东西，加深一下记忆。因为书讲的是tomcat4，5的内容，比较旧了，所以和最新的tomcat的差距还是有点大的。而且还没看完，以后再补充吧。</p><p>java那些用起来方便的东西，大多都是大佬们的封装，就和java线程的方式一样，不论是thread，runnable，callable,线程池等等方式，真正底层都是thread。tomcat看上去一个及其复杂的系统，追本溯源也就是socket 和 serversocket。</p><p>计算机网络之间的通信是基于端口之间通信，对于服务器，从端口读取数据，也就是inputStream， 往端口写数据，也就是outputStream。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">serverSocket = <span class="keyword">new</span> ServerSocket(<span class="number">8080</span>, <span class="number">1</span>, InetAddress</span><br><span class="line">.getByName(<span class="string">"127.0.0.1"</span>));</span><br><span class="line">socket = serverSocket.accept();</span><br><span class="line">input = socket.getInputStream();</span><br><span class="line">output = socket.getOutputStream();</span><br></pre></td></tr></table></figure><p>HttpServletRequest是请求，也就是客户端往服务器端口发送消息，服务器从端口读取数据，所以HttpServletRequest封装了上面的inputStream。 同理HttpServletResponse封装了上面的outputStream。</p><p>ServerSocket 监听本机端口， 我们可以去浏览器输入: <a href="http://127.0.0.1:8080" target="_blank" rel="noopener">http://127.0.0.1:8080</a> 然后后台读取程序中读取一个叫做index.html的文件(FileInputStream-&gt;bytes)，output.write(bytes, 0, lenth). 将文件内容输出到端口，网页中就会显示内容了。是不是有点熟悉。当然tomcat肯定不是这么简单的实现，但是最基本的原理就是如此。</p><p>当然这个是静态资源，如果是动态servlet的处理，大致是通过类加载器，加载进内存，反射得到对象。然后根据request请求信息，判断是请求静态文件还是动态servlet，然后执行servlet的service(request, response)方法;</p><h3 id="Connector-连接器"><a href="#Connector-连接器" class="headerlink" title="Connector 连接器"></a>Connector 连接器</h3><p>直接跳到连接器，有点太快了，书中还有很多小细节，门面设计模式， response中getWriter方法就是封装了outputStream… 推荐去看一下。</p><p>连接器，顾名思义，就是用来处理连接的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private int port = 8080;</span><br><span class="line">private ServerSocket serverSocket = null;</span><br></pre></td></tr></table></figure><p>这是我直接在tomcat4源码中HttpConnector拷贝过来的两个参数，然后再来看看这个类的一个重要方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Loop until we receive a shutdown command</span></span><br><span class="line">        <span class="keyword">while</span> (!stopped) &#123;</span><br><span class="line">            Socket socket = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                socket = serverSocket.accept();</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> () &#123;</span><br><span class="line">               ...</span><br><span class="line">            &#125;</span><br><span class="line">            HttpProcessor processor = createProcessor();</span><br><span class="line">            ...</span><br><span class="line">            processor.assign(socket);</span><br><span class="line">           ...</span><br><span class="line">        &#125;</span><br><span class="line">  ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>一个循环，等待连接的到来，得到一个socket对象， 然后创建一个处理器，去处理这个socket的请求。然后继续等待下一个连接accept()。</p><p>当然如果tomcat这样顺序进行，那肯定是不行的，所以一个连接器有一个processor(处理器)的对象池。而每个处理器实现了runnable接口，在创建的时候就启动了线程，然后阻塞自己，直到自己调用了assign() 方法，就是上面的那个方法，然后执行处理request的方法，处理servlet还是静态资源。完成后继续阻塞自己。</p><p>所以tomcat的connector有多个processor，请求来了调用一个processor去执行，而本身不需要等待这个processor完成，继续接收下一个请求。是一种异步实现的感觉。这样可以处理多个请求,而无需阻塞。这也是早期bio的解决方案。现在的解决方案应该是nio了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">final class HttpProcessor implements Lifecycle, Runnable &#123;</span><br><span class="line"></span><br><span class="line">public void run() &#123;</span><br><span class="line">        while (!stopped) &#123;</span><br><span class="line">        Socket socket = await();</span><br><span class="line">            if (socket == null)</span><br><span class="line">                continue;</span><br><span class="line">            try &#123;</span><br><span class="line">                process(socket);</span><br><span class="line">            &#125; catch (Throwable t) &#123;</span><br><span class="line">                log(&quot;process.invoke&quot;, t);</span><br><span class="line">            &#125;</span><br><span class="line">            connector.recycle(this);</span><br><span class="line">        &#125;</span><br><span class="line">        synchronized (threadSync) &#123;</span><br><span class="line">            threadSync.notifyAll();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>就是在await（）方法阻塞，然后释放，执行process完成，循环继续阻塞。</p><h3 id="processor-处理器"><a href="#processor-处理器" class="headerlink" title="processor 处理器"></a>processor 处理器</h3><p>首先看看这个processor做了什么吧。</p><ul><li>创建HttpServletRequest, HttpServletResponse对象。</li><li>解析连接</li><li>解析请求</li><li>解析头部， 给request.setHeader。</li><li>隐式调用了servlet的service方法。 虽然从这里开始，但并不是直接调用。</li></ul><p>具体是怎么解析的请求，我没有深入去了解，大概就是拆分字符串，截取之类的吧，还是看看这个类最重要的方法。process() 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private void process(Socket socket) &#123;</span><br><span class="line">   ...</span><br><span class="line">     try &#123;</span><br><span class="line">         input = new SocketInputStream(socket.getInputStream(),connector.getBufferSize());</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">    ...</span><br><span class="line">     &#125;</span><br><span class="line">     keepAlive = true;</span><br><span class="line">     while (!stopped &amp;&amp; ok &amp;&amp; keepAlive) &#123;</span><br><span class="line">         finishResponse = true;</span><br><span class="line">         try &#123;</span><br><span class="line">             request.setStream(input);</span><br><span class="line">             request.setResponse(response);</span><br><span class="line">             output = socket.getOutputStream();</span><br><span class="line">             response.setStream(output);</span><br><span class="line">             response.setRequest(request);</span><br><span class="line">             ((HttpServletResponse) response.getResponse()).setHeader(&quot;Server&quot;, SERVER_INFO);</span><br><span class="line">         &#125; catch (Exception e) &#123;</span><br><span class="line">...</span><br><span class="line">         &#125;</span><br><span class="line">          ...//这里解析请求，给丰富request和response。</span><br><span class="line">         try &#123;</span><br><span class="line">    ...</span><br><span class="line">             if (ok) &#123;</span><br><span class="line">                 // 重点。 画上！！！</span><br><span class="line">                 connector.getContainer().invoke(request, response);</span><br><span class="line">             &#125;</span><br><span class="line">         &#125; catch (ServletException e) &#123;</span><br><span class="line">                 ...</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>大致就是上面，可以看出，request和response封装了输入输出流，然后解析请求， 调用了container的invoke(request, response)方法。所以我们希望见到的service方法就藏在这里面了。</p><h3 id="Container-容器"><a href="#Container-容器" class="headerlink" title="Container 容器"></a>Container 容器</h3><p>这个可以说是tomat中最被人熟知的东西之一。tomcat4中有四大容器，以我的理解简单介绍一下， 可能有点不对。</p><ul><li>Engine 引擎， 启动一个tomcat服务，也就是启动一个引擎</li><li>host 虚拟主机， 一个Engine启动，下面项目都会启动，localhost:8080/work1,work2</li><li>context 上下文， 一个项目对应一个上下文，通过map映射到不同的servlet。</li><li>wrapper 包装器， 一个wrapper对应一个servlet。</li></ul><p>上面的四个都实现了Container接口，就先来谈谈wrapper吧。connector中有个方法，setContainer(Container container); 如果一个wrapper被一个connector绑定，那么回到上面画重点的方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.getContainer().invoke(request, response);</span><br></pre></td></tr></table></figure></p><h4 id="wrapper-包装器"><a href="#wrapper-包装器" class="headerlink" title="wrapper 包装器"></a>wrapper 包装器</h4><p>所以点进wrapper类中找寻这个方法，发现没有，这个方法的实现在他的父类ContainerBase中有实现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response) throws IOException, ServletException &#123;</span><br><span class="line">      pipeline.invoke(request, response);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>出现了一个新的东西，叫做管道(pipeline)。点下去，会发现很麻烦，先来捋一捋Container中这些的关系。</p><p><img src="/static/pic06.png" alt="pic"></p><p>container 中包含了一个pipeline， 而pipeline执行invoke方法是创建了一个pipelineContext对象，并执行invokeNext方法。 然后pipelineContext对象就会去执行Valve的invoke方法。当然，执行方式有点像递归，一直往下，直到执行basicvalve的invoke方法，这个方法中会隐式执行service方法，然后再回去执行上一个valve。看看basicvalve的invoke方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException &#123;</span><br><span class="line">...</span><br><span class="line">        StandardWrapper wrapper = (StandardWrapper) getContainer();</span><br><span class="line">        ServletRequest sreq = request.getRequest();</span><br><span class="line">        ServletResponse sres = response.getResponse();</span><br><span class="line">        Servlet servlet = null;</span><br><span class="line">        HttpServletRequest hreq = null;</span><br><span class="line">        if (sreq instanceof HttpServletRequest)</span><br><span class="line">            hreq = (HttpServletRequest) sreq;</span><br><span class="line">        HttpServletResponse hres = null;</span><br><span class="line">        if (sres instanceof HttpServletResponse)</span><br><span class="line">            hres = (HttpServletResponse) sres;</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            if (!unavailable) &#123;</span><br><span class="line">// 划重点。。。</span><br><span class="line">                servlet = wrapper.allocate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; catch (ServletException e) &#123;</span><br><span class="line">     ...</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ApplicationFilterChain filterChain = createFilterChain(request, servlet);</span><br><span class="line"></span><br><span class="line">        try &#123;</span><br><span class="line">            ...</span><br><span class="line">            if ((servlet != null) &amp;&amp; (filterChain != null)) &#123;</span><br><span class="line">   // 划重点2。。。</span><br><span class="line">                filterChain.doFilter(sreq, sres);</span><br><span class="line">            &#125;</span><br><span class="line">  ...</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>通过getContainer得到wrapper， wrapper.allocate(). 这个方法中通过反射之类的得到了servlet对象，返回。然后创建一个过滤器链， 调用doFilter方法传递request和response。我们再看看doFilter方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((request instanceof HttpServletRequest) &amp;&amp;(response instanceof HttpServletResponse)) &#123;</span><br><span class="line">servlet.service((HttpServletRequest) request, (HttpServletResponse) response);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">servlet.service(request, response);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法中，终于找到了调用service方法了。当然上面说的都是wrapper。一个wrapper只对应一个servlet，但是一个项目肯定有多个servlet，那么这就涉及到我们熟悉的Context(上下文)了。</p><h4 id="context-上下文"><a href="#context-上下文" class="headerlink" title="context 上下文"></a>context 上下文</h4><p>我们再回到connector，connector.setContainer(context). 如果connector设置的容器是上下文。再来分析一下。想起我们之前的那个方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connector.getContainer().invoke(request, response);</span><br></pre></td></tr></table></figure></p><p>context的invoke和wrapper一样，pipeline.invoke,  然后同样是pipelineContext.invokeNext。 那么不一样的地方在哪里呢？ 那就是basicvalve， 我们称为contextValve。 我们看看contextValve的invoke方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void invoke(Request request, Response response, ValveContext valveContext) throws IOException, ServletException &#123;</span><br><span class="line">    ...</span><br><span class="line">        Context context = (Context) getContainer();</span><br><span class="line">        Wrapper wrapper = null;</span><br><span class="line">        try &#123;</span><br><span class="line">            wrapper = (Wrapper) context.map(request, true);</span><br><span class="line">        &#125; catch (IllegalArgumentException e) &#123;</span><br><span class="line">            badRequest(requestURI, (HttpServletResponse) response.getResponse());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        if (wrapper == null) &#123;</span><br><span class="line">            notFound((HttpServletResponse) response.getResponse());</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        response.setContext(context);</span><br><span class="line">        wrapper.invoke(request, response);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>相当简洁， 就是context从request中读取到类似 /IndexServlet， 然后就会去map中搜索，找到处理这个IndexServlet的servlet。也就是wrapper，执行wrapper的invoke，又回到了上面wrapper的方法，记得上面的说的吗，一个wrapper只处理一个servlet。而一个上下文对应多个servlet。 而这里的map就是我们经常写的xml映射关系。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;  </span><br><span class="line">      &lt;servlet-name&gt;IndexServlet&lt;/servlet-name&gt;  </span><br><span class="line">      &lt;url-pattern&gt;/IndexServlet&lt;/url-pattern&gt;  </span><br><span class="line">&lt;/servlet-mapping&gt;</span><br></pre></td></tr></table></figure></p><p>当然这个map有一个专门的类ContextMapper， 这个就不深究如何映射的。还有上面类加载，反射servlet的方法，其实也有一个专门的接口叫Loader。我也没看太懂。</p><p>然后至于host和engine的实现，没看完，看看以后看完了有时间再来补上。原理应该差不多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;上上个星期，看了一下how tomcat works这本书，今天捡起来看一会，发现忘得有点快，特地写点东西，加深一下记忆。因为书讲的是tomcat4，5的内容，比较旧了，所以和最新的tomcat的差距还是有点大的。而且还没看完，以后再补充吧。&lt;/p&gt;
&lt;p&gt;java那些用起
      
    
    </summary>
    
      <category term="JAVA" scheme="https://ipanyiwen.github.io/categories/JAVA/"/>
    
    
      <category term="tomcat" scheme="https://ipanyiwen.github.io/tags/tomcat/"/>
    
  </entry>
  
  <entry>
    <title>java-concurrent的基石-AQS</title>
    <link href="https://ipanyiwen.github.io/2018/11/18/java-concurrent%E7%9A%84%E5%9F%BA%E7%9F%B3-AQS/"/>
    <id>https://ipanyiwen.github.io/2018/11/18/java-concurrent的基石-AQS/</id>
    <published>2018-11-17T16:02:10.000Z</published>
    <updated>2018-12-16T19:14:56.060Z</updated>
    
    <content type="html"><![CDATA[<p>学习java的并发包(JUC, java.util.concurrent)，自然就回想起几个著名的类: ReentrantLock、Semaphore、CountDownLatch等。而在这些类都是基于AQS(AbstractQueuedSynchronizer)实现的,一个抽象模板类。 了解和学习AQS， 可以更好的理解和掌握JUC。</p><p>AQS支持共享和非共享两种模式，非共享对应的有ReentrantLock， 而共享对应的有CountDownLatch，semaphore等。</p><p>AQS的数据结构其实比较简单， 大致这个样子。</p><p><img src="&quot;/static/pic07.png&quot;" alt="pic"></p><ol><li>head 和 tail 类型都是AQS的内部类-&gt; node类型，</li><li>state是一个int类型.也就是互斥/共享资源，state&gt;0 资源被占用， state==0 资源被释放。</li></ol><h3 id="两种模式"><a href="#两种模式" class="headerlink" title="两种模式"></a>两种模式</h3><p>独占模式:</p><ul><li>ReentrantLock:</li><li>state为0代表资源未被占有，可以获取锁并设置为1，此时其他线程访问为1，代表资源已经被锁上(占有)，所以线程自身进入lock(AQS)的双向队列中,等待资源释放。</li></ul><p>共享模式:  </p><ul><li>CountDownLatch:</li><li>一个线程(一般是主线程) latch = new CountDownLatch(num); 即state设为num</li><li>latch.await(); 将线程自身加入latch(AQS)的双向队列，等待资源释放</li><li>latch.countDown(); 将state-1,一旦state为0说明资源被释放。(一般是其他线程执行完成)，之前await的线程可以继续执行。</li></ul><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><p>talk is cheap show me the code<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">5</span>);</span><br><span class="line">semaphore.acquire();</span><br><span class="line"><span class="comment">//doSometing</span></span><br><span class="line">semaphore.release();</span><br></pre></td></tr></table></figure></p><p>最近用到了semaphore用来限流。 也就是dosometing的代码非常消耗内存，如果并发高很容易出现oom。这个时候就可以根据分配的Xmx和dosometing的计算最大并发个数，进行限制。</p><p>那么如何实现的并发控制，点进源码see see。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//semaphore 类的定义。</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Semaphore</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line">    <span class="keyword">abstract</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// somemethods 几乎都和sync 内部类对象有关，而Sync实现的就是AQS.</span></span><br></pre></td></tr></table></figure><h3 id="acquire方法"><a href="#acquire方法" class="headerlink" title="acquire方法"></a>acquire方法</h3><p>那么先来看看acquire方法。实际执行的是sync的acquireSharedInterruptibly(1)</p><p>该方法没有被重写，在AbstractQueuedSynchronizer类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())   <span class="comment">// 线程是否中断</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">// 尝试获取资源 小于0 获取失败</span></span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="comment">// 加到阻塞队列中，会再次尝试是否能获取资源。</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>也就是尝试获取资源，发现此时资源已经被用完，所以自身线程加入aqs队列，将自己阻塞起来。</p><p>tryAcquireShared方法:</p><p>该方法重写了，在Semaphore类中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> sync.nonfairTryAcquireShared(<span class="number">1</span>) &gt;= <span class="number">0</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">    <span class="keyword">int</span> available = getState();</span><br><span class="line">    <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">    <span class="comment">// 没有资源， 获取资源失败/成功。返回剩余资源数量。没有则 &lt; 0.</span></span><br><span class="line">    <span class="comment">// compareAndSetState cas操作。 尝试将资源 state = available - acquires</span></span><br><span class="line">    <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> || compareAndSetState(available, remaining))</span><br><span class="line">        <span class="keyword">return</span> remaining;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>可以看到，如果有资源，则资源减一，返回的数大于等于0， 不阻塞。 反之， 没有资源，那么执行doAcquireSharedInterruptibly() 操作，再次尝试，如果失败则阻塞。</p><p>doAcquireSharedInterruptibly 方法:</p><p>该方法没有被重写，在AbstractQueuedSynchronizer类中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="comment">/**这个addWaiter 很讲究，大致就是将自己这个线程加入到aqs的阻塞队列的末尾。</span></span><br><span class="line"><span class="comment">     *  Node node = new Node(Thread.currentThread(), mode); 并返回node</span></span><br><span class="line"><span class="comment">     *  如果是第一个阻塞， 会生产一个空head.</span></span><br><span class="line"><span class="comment">     * 不过为了保证线程安全，用了cas操作</span></span><br><span class="line"><span class="comment">     * 先尝试一遍放在队列末尾，如果失败，进入enq方法，</span></span><br><span class="line"><span class="comment">     * 无限循环尝试放在阻塞队列的末尾. (自旋锁)</span></span><br><span class="line"><span class="comment">     * 而且head节点是一个空节点，new Node(); 不存储数据。</span></span><br><span class="line"><span class="comment">    **/</span></span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/** 无限循环，尝试获取资源，</span></span><br><span class="line"><span class="comment">         *  是否应该阻塞， 调用原语阻塞自身。</span></span><br><span class="line"><span class="comment">         *  当前线程停止在if(xxx &amp;&amp; parkAndCheckInterrupt)处。</span></span><br><span class="line"><span class="comment">         *  一旦有资源被释放， 从此处唤醒，继续无限循环尝试获取资源。</span></span><br><span class="line"><span class="comment">        **/</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">/** 如果当前节点的前一个是head，而head是个标记，不存储数据，</span></span><br><span class="line"><span class="comment">             *  说明前面没有阻塞的node节点，那么再尝试获取一遍资源。</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/** shouldParkAfterFailedAcquire 从阻塞队列末尾往前查看，</span></span><br><span class="line"><span class="comment">             * 看看前面的资源是否被阻塞，如果被阻塞自己就排在后面也阻塞起来，</span></span><br><span class="line"><span class="comment">             * 如果没有被阻塞，说明前面这个线程放弃了，从队列中删除</span></span><br><span class="line"><span class="comment">             * 回到上面循环，重新尝试获取资源。然后再阻塞自己。</span></span><br><span class="line"><span class="comment">             * 将自身的前一个节点的waitStatus设置为SIGNAL，等待资源唤醒。</span></span><br><span class="line"><span class="comment">             * 所以node.waitStatus 是指下一个节点需要的状态(等待唤醒, 取消...)</span></span><br><span class="line"><span class="comment">             * parkAndCheckInterrupt 调用原语，阻塞自己。</span></span><br><span class="line"><span class="comment">            **/</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到这里阻塞就算是完成了。线程没有获取到资源，全都暂停在parkAndCheckInterrupt。等待其他拥有资源的线程release，那么就会唤醒阻塞的线程，重新回到for(;;)。 重新获取资源。</p><h3 id="release方法"><a href="#release方法" class="headerlink" title="release方法"></a>release方法</h3><p>线程释放资源调用 release方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span> </span>&#123;sync.releaseShared(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该方法没有被重写，在AbstractQueuedSynchronizer类中</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="comment">// 无限循环尝试释放资源， state=state+1， 释放成功</span></span><br><span class="line">       <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">// 释放成功， 唤醒线程抢夺资源。。。</span></span><br><span class="line">           doReleaseShared();</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>和acquire方法相反， release方法释放资源，然后doReleaseShared 唤醒之前被阻塞在parkAndCheckInterrupt 方法的线程。</p><p>doReleaseShared 方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果阻塞队列中有数据。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;   </span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="comment">// 如果h的状态是等待唤醒</span></span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                <span class="comment">// 唤醒一个后继节点</span></span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将设置为共享模式。到了这一步，说明阻塞队列为空。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这次循环头节点没有变化，阻塞队列全部被唤醒。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个代码也是一个无限循环(闭锁)，然后唤醒所有没有放弃的后继节点。线程就会回到上面doAcquire中继续循环。抢占资源或者继续阻塞。等待唤醒。</p><p>unpartSuccessor方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">private void unparkSuccessor(Node node) &#123;</span><br><span class="line">    int ws = node.waitStatus;</span><br><span class="line">    // 修改状态</span><br><span class="line">    if (ws &lt; 0)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, 0);</span><br><span class="line"></span><br><span class="line">    // head.next 才是需要唤醒的线程节点。</span><br><span class="line">    Node s = node.next;</span><br><span class="line">    // 如果next放弃了。修改s位置。</span><br><span class="line">    if (s == null || s.waitStatus &gt; 0) &#123;</span><br><span class="line">        s = null;</span><br><span class="line">        for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            if (t.waitStatus &lt;= 0)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    // s不为空，执行原语，唤醒阻塞线程。</span><br><span class="line">    if (s != null)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>到了这里才是真正唤醒线程。而互斥与之差不多，不过是资源数变成1，互斥访问。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;学习java的并发包(JUC, java.util.concurrent)，自然就回想起几个著名的类: ReentrantLock、Semaphore、CountDownLatch等。而在这些类都是基于AQS(AbstractQueuedSynchronizer)实现的,一
      
    
    </summary>
    
      <category term="JAVA" scheme="https://ipanyiwen.github.io/categories/JAVA/"/>
    
    
      <category term="java并发" scheme="https://ipanyiwen.github.io/tags/java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>商汤java实习生面试题</title>
    <link href="https://ipanyiwen.github.io/2018/09/09/%E5%95%86%E6%B1%A4java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://ipanyiwen.github.io/2018/09/09/商汤java面试题/</id>
    <published>2018-09-09T11:10:47.000Z</published>
    <updated>2018-09-09T11:33:13.899Z</updated>
    
    <content type="html"><![CDATA[<p>前两天面深圳商汤，java实习生。记录一下。</p><h4 id="技术一面。"><a href="#技术一面。" class="headerlink" title="技术一面。"></a>技术一面。</h4><ol><li>前台传递数据给后台的详细过程。画图</li><li>https协议，运用了加密。过程是什么？</li><li>servlet实现了什么接口。没答上来。退而求次，回答了servlet里面有什么方法。</li><li>多线程，平时用到了什么锁，ThreadLocal。CAS。不使用锁保证线程安全等。</li><li>数据库，事务。隔离级别。</li><li>集合有哪些。适用范围，什么场合。</li><li>int和Integer的127范围双等问题。为什么选127这个数字。</li><li>jvm底层的一些原理，知不知道Java使用了除了jvm的那五个外还使用了系统内存的什么方面。</li><li>保证多线程安全的方式，除了加锁和CAS还有什么技术。</li><li>如果不用tomcat等web服务器，如何实现http过程。</li><li>tomcat会做些什么。之类的。</li><li>数据库ACID。各是什么。介绍一下。</li><li>强，软，弱，虚引用，什么场景需要用到这些引用。</li></ol><p>然后要手写求一堆数据的第K大。不会，堆排怕写错，只好手写快排。 其实后来想想应该写快排剪枝。时间复杂度应该接近O(n)</p><h4 id="技术二面"><a href="#技术二面" class="headerlink" title="技术二面."></a>技术二面.</h4><ol><li>springboot了解多少。常用的注解。</li><li>看过什么书，深入jvm底层原理那本看没看。</li><li>平时喜欢逛论坛博客。学习Java哪方面的知识</li><li>有没有用到多线程。继续多线程。</li><li>数据库事务，隔离级别。</li><li>spring事务，隔离级别。</li><li>sql优化。索引原理。b树和b+树的区别。</li><li>jvm内存结构。</li><li>介绍常量池。Java都是引用类型。所以String的双等。（脑袋有点懵，居然这么简单都答错了）。</li><li>spring事务传播级别有哪些。怎么实现。</li><li>jvm底层之类的。</li></ol><p>还有一些来着。想不起来了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;前两天面深圳商汤，java实习生。记录一下。&lt;/p&gt;
&lt;h4 id=&quot;技术一面。&quot;&gt;&lt;a href=&quot;#技术一面。&quot; class=&quot;headerlink&quot; title=&quot;技术一面。&quot;&gt;&lt;/a&gt;技术一面。&lt;/h4&gt;&lt;ol&gt;
&lt;li&gt;前台传递数据给后台的详细过程。画图&lt;/li&gt;
      
    
    </summary>
    
      <category term="其他" scheme="https://ipanyiwen.github.io/categories/%E5%85%B6%E4%BB%96/"/>
    
    
      <category term="面试题" scheme="https://ipanyiwen.github.io/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>servlet中destory方法的误解</title>
    <link href="https://ipanyiwen.github.io/2018/07/09/servlet%E4%B8%ADdestory%E6%96%B9%E6%B3%95%E7%9A%84%E8%AF%AF%E8%A7%A3/"/>
    <id>https://ipanyiwen.github.io/2018/07/09/servlet中destory方法的误解/</id>
    <published>2018-07-09T12:39:28.000Z</published>
    <updated>2018-07-09T12:57:27.413Z</updated>
    
    <content type="html"><![CDATA[<p>最近学习servlet的过程中发现了一个很怪的问题， 百度上面搜索这个问题也几乎都是错误的理解。那就是有关servlet在什么时候摧毁，回答很多是服务器关闭或者执行destory方法。服务器关闭servlet肯定会销毁，但是执行destory并不会销毁servlet。</p><p>我尝试手动调用destory方法。然后再去调用GET方法。发现还是会执行get， 也就是说执行了destory方法并不会销毁servlet。我就怀疑是不是服务器重新创建了一个servlet。然后我继续测试</p><p>用ajax测试的结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">本次请求的方式为：PUT</span><br><span class="line">本次请求的方式为：GET</span><br><span class="line">本次请求的方式为：DESTORY</span><br><span class="line">servlet.IndexServlet@36cfac98</span><br><span class="line">正在销毁servlet。。。</span><br><span class="line">本次请求的方式为：GET</span><br><span class="line">本次请求的方式为：DESTORY</span><br><span class="line">servlet.IndexServlet@36cfac98</span><br><span class="line">正在销毁servlet。。。</span><br></pre></td></tr></table></figure></p><p>打印了servlet的地址，发现前后是同一个servlet。所以servlet并没有销毁。</p><p>断点跟踪发现super.destory()是一个空方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//方法写在GenericServlet类中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>也就是这个方法并不是真正销毁servlet。所以我的理解是：</p><p>服务器关闭或者销毁servlet的时候会执行destory方法告知使用者，我要销毁这个servlet了。而我们手动执行destory方法并不会真的销毁servlet。</p><p>如理解错误望告知！谢谢。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;最近学习servlet的过程中发现了一个很怪的问题， 百度上面搜索这个问题也几乎都是错误的理解。那就是有关servlet在什么时候摧毁，回答很多是服务器关闭或者执行destory方法。服务器关闭servlet肯定会销毁，但是执行destory并不会销毁servlet。&lt;/p
      
    
    </summary>
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="JAVA" scheme="https://ipanyiwen.github.io/categories/%E9%9A%8F%E7%AC%94/JAVA/"/>
    
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>ubuntu16.04科学上网</title>
    <link href="https://ipanyiwen.github.io/2018/07/08/ubuntu16-04%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>https://ipanyiwen.github.io/2018/07/08/ubuntu16-04科学上网/</id>
    <published>2018-07-08T11:59:48.000Z</published>
    <updated>2018-07-08T12:53:44.198Z</updated>
    
    <content type="html"><![CDATA[<p>今天折腾了一下科学上网。系统ubuntu16.04， 记录一下。</p><p>先装个shadowsocks。图形化界面，简单操作。^.^</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:hzwhuang/ss-qt5</span><br><span class="line">sudo apt-get update</span><br><span class="line">sudo apt-get install shadowsocks-qt5</span><br></pre></td></tr></table></figure><p>打开软件，添加服务器地址，端口等必要信息。恩，这个要么买，要么网上找免费的，要么自己搭。</p><p>因为shadowsocks默认是socks5,所以要想在浏览器用http访问，还是需要再装个软件polipo。将socks5转http。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install polipo</span><br></pre></td></tr></table></figure><p>到配置文件下 /etc/polipo/config，设置polipo。<br>将下面的文件替换原来的config。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#This file only needs to list configuration variables that deviate</span><br><span class="line"># from the default values. See /usr/share/doc/polipo/examples/config.sample</span><br><span class="line"># and &quot;polipo -v&quot; for variables you can tweak and further information.</span><br><span class="line">logSyslog = false</span><br><span class="line">logFile = &quot;/var/log/polipo/polipo.log&quot;</span><br><span class="line"></span><br><span class="line">socksParentProxy = &quot;127.0.0.1:1080&quot;</span><br><span class="line">socksProxyType = socks5</span><br><span class="line"></span><br><span class="line">chunkHighMark = 50331648</span><br><span class="line">objectHighMark = 16384</span><br><span class="line"></span><br><span class="line">serverMaxSlots = 64</span><br><span class="line">serverSlots = 16</span><br><span class="line">serverSlots1 = 32</span><br><span class="line"></span><br><span class="line">proxyAddress = &quot;0.0.0.0&quot;</span><br><span class="line">proxyPort = 8123</span><br></pre></td></tr></table></figure><p>重启polipo的服务。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service polipo restart</span><br></pre></td></tr></table></figure></p><p>最后设置一下代理，如果只用火狐浏览器，可以在火狐浏览器的设置，首选项 &gt; 网络代理 &gt; 手动代理设置 。</p><p><img src="/static/pic04.png" alt="pic"></p><p>如果你有多个浏览器，可以在系统中直接设置全局。进入系统的设置 &gt; 网络 &gt; 网络代理</p><p><img src="/static/pic05.png" alt="pic"></p><p>设置完成，开心的科学上网吧^.^。</p><p>问题：</p><p>虽然上面的确可以做到科学上网，但是关闭起来挺麻烦的，首先关掉shadowsocks软件。然后关闭polipo服务 service polipo stop，最后去浏览器或者系统设置中将网络代理改为无。才能回到原来的状态。下次启动再改回来，如果资源比较充足的话，服务可以不关闭并设置开机自启动。那样关闭就只需两步。还是挺方便的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;今天折腾了一下科学上网。系统ubuntu16.04， 记录一下。&lt;/p&gt;
&lt;p&gt;先装个shadowsocks。图形化界面，简单操作。^.^&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;
      
    
    </summary>
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>http简史-互联网浪潮中的重要角色</title>
    <link href="https://ipanyiwen.github.io/2018/07/05/http%E5%8D%8F%E8%AE%AE-%E4%BA%92%E8%81%94%E7%BD%91%E6%B5%AA%E6%BD%AE%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E8%A7%92%E8%89%B2/"/>
    <id>https://ipanyiwen.github.io/2018/07/05/http协议-互联网浪潮中的重要角色/</id>
    <published>2018-07-05T00:54:48.000Z</published>
    <updated>2018-11-17T16:02:59.304Z</updated>
    
    <content type="html"><![CDATA[<p>这是一篇关于http的历史故事。HTTP 超文本传输协议（HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。本文不重点介绍http协议中的语法和传输协议的实现。我们只是简单入门，了解这些年http协议的变化，和在互联网的浪潮中发挥的重要作用。</p><h2 id="1-1980年"><a href="#1-1980年" class="headerlink" title="1, 1980年"></a>1, 1980年</h2><p>让我们搭上时光机，回溯的到上个世纪80年代（1980），那个时候tcp/ip模型已经提出，ISO模型差不多在这个时间段提出(1981)，因为网络模型的建立，人们之间已经可以通过网络进行通信。然而令人遗憾的是，那个时候HTML标准都还没制定，更别说浏览器。所以像现在这样没事开个网页，看看信息在那个时代还是不存在的。然而在1980年代后期超文本技术已经出现，当时还有国际间的超文本学术会议，每次都有上百篇的有关超文本的论文问世，但没有人能想到把超文本技术应用到计算机网络上来。</p><h2 id="2-1990年"><a href="#2-1990年" class="headerlink" title="2, 1990年"></a>2, 1990年</h2><p>时光荏苒,转眼间10年过去了。一个名叫 Tim Berners-Lee的人横空出世。他在1990年构思了HTML， SGML（标准通用标记语言）的产物。当然那个时候还没有制定一套标准。最重要的是他发明了世界上首个网页浏览器。喜大普奔！！！</p><p>1991年，他创建了世界上第一个网页： <a href="http://info.cern.ch/hypertext/WWW/TheProject.html" target="_blank" rel="noopener"> http://info.cern.ch/hypertext/WWW/TheProject.html</a> 当然，这个网页看上去就很NB，和现在市面上的网页完全不一样。</p><h3 id="2-1-http-0-9"><a href="#2-1-http-0-9" class="headerlink" title="2.1 http 0.9"></a>2.1 http 0.9</h3><p>与此同时，他还制定了一个协议，基于TCP协议(网络层)，位于应用层，用来访问他的网页。大概是这个样子的。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">GET /dir/index.html</span><br></pre></td></tr></table></figure><p>没错，你没有看错。 这个就是传说中的http协议的最初版本， HTTP 0.9。只有一个GET， 后面跟着需要访问的html网页，只能是html网页，不是资源。然后就会建立TCP链接。</p><p>返回的也什么都没有，只有一个html。我们用telnet访问以下本地的apache2服务器。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">telnet localhost 80</span><br><span class="line"></span><br><span class="line">GET /index.html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>启动成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><p>返回一个html页面。然后关闭链接TCP链接。</p><h3 id="2-2-互联网热潮"><a href="#2-2-互联网热潮" class="headerlink" title="2.2 互联网热潮"></a>2.2 互联网热潮</h3><p>在1991-1995年，这段时间HTML标准被定义的比较完善，一款叫做浏览器的应用风靡全球，也是在这个时间段内,W3C(万维网联盟)成立了 —— 1994年10月。创立者, 恩，没错，还是那个男人Tim Berners-Lee。而随着互联网的风靡，HTTP/0.9暴露出来的问题也越来越多。首先就是丰富的数据，人们不再想看光秃秃的文字，还想看光鲜亮丽的小姐姐图片，想听音乐… 其次随着越来越多网络应用的出现, http0.9很难担负起这个重任。</p><h3 id="2-3-http-1-0"><a href="#2-3-http-1-0" class="headerlink" title="2.3 http 1.0"></a>2.3 http 1.0</h3><p>1996年5月。民心所向，http1.0版本发布。相比较0.9，http 1.0的内容大大丰富了。下面就简单介绍一下。</p><ol><li>任何格式： 互联网不再是只可以传输文字，还能传输图像、音频，视频、二进制文件的等。</li><li>http命令：除了GET外还支持POST命令和HEAD命令。当然现在不止支持这些。应该是发展过程加上去的。</li><li>请求头和响应头： 除了具有HTTP版本号的请求行，后还需要跟请求标头，响应状态，后跟响应标头，然后是响应正文。请求和响应头都保存为ASCII编码，但响应对象本身可以是任何类型：HTML文件，纯文本文件，图像或任何其他内容类型。</li><li>其他常用功能：内容编码，字符集支持，多部分类型，授权，缓存，代理行为，日期格式等。</li></ol><p>http/1.0协议的出现，让之前超文本传输协议的变成超媒体传输协议。但是可能是懒的原因，也就没改名了。<br>http/1.0就和现在的协议很像.但是现在服务器可能都做了优化，发送1.0请求回应都是1.1 ，弄了好久放弃了。例子：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">telnet&gt;</span><br><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0)</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 05 Jul 2018 02:55:49 GMT</span><br><span class="line">Server: Apache/2.4.33 (Ubuntu)</span><br><span class="line">Upgrade: h2,h2c</span><br><span class="line">Connection: Upgrade, close</span><br><span class="line">Last-Modified: Wed, 27 Jun 2018 08:42:36 GMT</span><br><span class="line">ETag: "18b-56f9b98ba3b98"</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 395</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Link: <span class="tag">&lt;/<span class="name">style.css</span>&gt;</span>; rel=preload; as=style</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"style.css"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">"text-align:center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>启动成功<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">img</span> <span class="attr">hidden</span> <span class="attr">src</span>=<span class="string">"images/end1.jpg"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line">Connection closed by foreign host.</span><br></pre></td></tr></table></figure><h4 id="2-3-1-http-1-0-的请求："><a href="#2-3-1-http-1-0-的请求：" class="headerlink" title="2.3.1 http/1.0 的请求："></a>2.3.1 http/1.0 的请求：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">User-Agent: User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0)</span><br><span class="line">Accept: */*</span><br></pre></td></tr></table></figure><p>第一行是请求命令，尾部必须添加协议版本HTTP/1.0 -必须大写！。</p><p>后跟请求头：</p><ol><li>User-Agent：用户的浏览器。</li><li>Accept: 接受的文件格式。 */* 所有文件。</li></ol><h4 id="2-3-2-http-1-0-的响应。-因为我没法测试，-就用网上的吧。"><a href="#2-3-2-http-1-0-的响应。-因为我没法测试，-就用网上的吧。" class="headerlink" title="2.3.2 http/1.0 的响应。 因为我没法测试， 就用网上的吧。"></a>2.3.2 http/1.0 的响应。 因为我没法测试， 就用网上的吧。</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.0 200 OK</span><br><span class="line">Content-Type: text/plain</span><br><span class="line">Content-Length: 137582</span><br><span class="line">Expires: Thu, 01 Dec 1997 16:00:00 GMT</span><br><span class="line">Last-Modified: Wed, 1 May 1996 12:45:26 GMT</span><br><span class="line">Server: Apache 0.84</span><br><span class="line"></span><br><span class="line">&lt;html&gt;....&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>第一行响应格式， 响应状态。</p><p>后跟响应头：</p><ol><li>Content-Type：响应数据。请求头响应头都是ascii码，但是响应数据可以任意，这个就是告知浏览器响应数据的格式式。</li><li>Content-Length：文件长度。</li><li>Expires：缓存失效日期</li><li>Last-Modified： 最后修改时间</li><li>server： 服务器</li></ol><p>再跟响应体。</p><p>关闭链接。</p><h4 id="2-3-3-笔记："><a href="#2-3-3-笔记：" class="headerlink" title="2.3.3 笔记："></a>2.3.3 笔记：</h4><p>至今服务器和浏览器都还支持http1.0。但是http1.0继承的0.9的传统，每次请求都需要重新建立连接。这个十分耗费资源。 see： 三次握手，慢启动。而且当时http1.0是没有Keep-Alive属性的。只是在1.1出现之后才追加回去的。</p><h3 id="2-4-http-1-1"><a href="#2-4-http-1-1" class="headerlink" title="2.4 http 1.1"></a>2.4 http 1.1</h3><p>1997年1月。比1.0仅仅晚了6个月。直接发布了http 1.1。然后在2年半后的1999年6月，对http1.1进行一次更新。然后http 1.1协议至今还在使用。</p><p>http 1.1解决了一些歧义问题， 当然引入了最重要的一个东西：KeepAlive连接。还有分包传输，字节范围请求，缓存机制, Host等。http1.1要求必须加上host。</p><p>例子：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.0</span><br><span class="line">Host: localhost</span><br><span class="line">User-Agent: User-Agent: Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:60.0)</span><br><span class="line">Accept: */*</span><br><span class="line"></span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Date: Thu, 05 Jul 2018 03:32:17 GMT</span><br><span class="line">Server: Apache/2.4.33 (Ubuntu)</span><br><span class="line">Upgrade: h2,h2c</span><br><span class="line">Connection: Upgrade, close</span><br><span class="line">Last-Modified: Wed, 27 Jun 2018 08:42:36 GMT</span><br><span class="line">ETag: "18b-56f9b98ba3b98"</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Content-Length: 395</span><br><span class="line">Vary: Accept-Encoding</span><br><span class="line">Link: <span class="tag">&lt;/<span class="name">style.css</span>&gt;</span>; rel=preload; as=style</span><br><span class="line">Content-Type: text/html</span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>...<span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>这个请求头和响应头与1.0的语法是一致的。就稍微介绍一下吧。</p><p>Host: 指名需要访问的域名。现在一台服务器可以对应多个域名,也就是这个Host给虚拟主机出现提供了支持。</p><p>启动的分包传输编码：Transfer-Encoding: chunked</p><h4 id="持久连接（Persistent-Connection）"><a href="#持久连接（Persistent-Connection）" class="headerlink" title="持久连接（Persistent Connection）"></a>持久连接（Persistent Connection）</h4><p>http1.1 于 http 1.0 最大的区别在于keepalive，它允许我们重用现有的TCP连接，以便对同一主机发出多个请求。当然，http1.0 后来也添加了这个字段提供长久支持。但是默认是不开启的。而http 1.1 默认开始，而且不需要写这个字段就可以。虽然是长连接，但是只是减少了三次握手次数，请求次数还是有多少html文件，图片，css， js 就需要请求多少次的。</p><p>终止这个连接。 客户端和服务器有一方提出关闭，连接就会断开。当然一段时间无响应也会关闭，但是最正确的写法自然是客户端在得到所有资源并不需要新的请求后发送colse请求(Connection: close)。</p><h4 id="100状态码"><a href="#100状态码" class="headerlink" title="100状态码"></a>100状态码</h4><p>HTTP/1.1加入了一个新的状态码100（Continue）。客户端事先发送一个只带头域的请求，如果服务器因为权限拒绝了请求，就回送响应码401（Unauthorized）；如果服务器接收此请求就回送响应码100，客户端就可以继续发送带实体的完整请求了。100 (Continue) 状态代码的使用，允许客户端在发request消息body之前先用request header试探一下server，看server要不要接收request body，再决定要不要发request body。</p><p>此外，HTTP/1.1协议添加了内容，编码，字符集，甚至语言协商，传输编码，缓存指令，客户端cookie，以及可以在每个请求上协商的十几种其他功能，还新增了指令：PUT、PATCH、HEAD、 OPTIONS、DELETE。这里就不讲解了。</p><h2 id="3-2009年"><a href="#3-2009年" class="headerlink" title="3, 2009年"></a>3, 2009年</h2><p>从1997年到2009年互联网一直使用的都是http1.1协议。这段时间互联网的发展也是异常迅速，http1.1的一系列的优化也在这段时间出现。在2009年google退出了SPDY 协议，为了解决 HTTP/1.1 效率不高的问题。随后在推行几年的时间内得到广泛认同后，作为http/2的基础。</p><h2 id="4-2012年"><a href="#4-2012年" class="headerlink" title="4, 2012年"></a>4, 2012年</h2><p>随着互联网越来越普及，不论是网上购物，阅读，支付，看视频，听音乐，聊天，新闻等，各式各样的方式使用http1.1协议也显示出了有压力的迹象，http协议也需要进行变革，在2012年初，HTTPbis working group 提出了http/2的计划。</p><h2 id="5-2015年"><a href="#5-2015年" class="headerlink" title="5, 2015年"></a>5, 2015年</h2><p>http/2 协议在2015年正式推出。http/2 协议基本继承了SPDY协议。而且不会再出现2.x的版本。<br>HTTP / 2（最初命名为HTTP / 2.0）是万维网使用的HTTP网络协议的主要修订版。它源于早期的实验性SPDY协议，最初由谷歌开发。在开放互联网上HTTP 2.0将只用于https://网址，而 http:// 网址将继续使用HTTP/1.x</p><h3 id="5-1-HTTP-2"><a href="#5-1-HTTP-2" class="headerlink" title="5.1 HTTP/2"></a>5.1 HTTP/2</h3><p>HTTP / 2的重点是提高传输性能并实现更低的延迟和更高的吞吐量。最重要的是，没有任何高级协议语义受到影响：所有HTTP头，值和用法都是和http1.1相同。也就是现有的所有web应用需要转http/2协议不需要修改任何http有关的字段。当然服务器必须支持且开启http/2。</p><p>不同的是http/1.x 版本的头字段是ascii码，而数据体可以是任何格式，而http/2不论是头还是数据体都是二进制，帧（Frame）：HTTP/2通信的最小单位，每个帧包含帧首部，会标识出当前帧所属的流。消息（Message）：由一个或多个帧组合而成，例如请求和响应。</p><h4 id="5-1-1-http-2消息发送"><a href="#5-1-1-http-2消息发送" class="headerlink" title="5.1.1 http/2消息发送"></a>5.1.1 http/2消息发送</h4><p>在HTTP/2中，数据流以消息的形式发送，而消息由一个或多个帧组成，帧可以在数据流上乱序发送，然后再根据每个帧首部的流标识符重新组装。</p><h4 id="5-1-2-多路复用"><a href="#5-1-2-多路复用" class="headerlink" title="5.1.2 多路复用"></a>5.1.2 多路复用</h4><p>HTTP/2 在一个tcp连接中，客户端和浏览器可以同时发送多个请求和响应，而且不论顺序。哪怕某个消息处理很耗时，并不会影响其他请求， 因为是以帧的形式发送，而帧的头部记录了所属请求，所以提升了效率。</p><h4 id="5-1-3-头部压缩"><a href="#5-1-3-头部压缩" class="headerlink" title="5.1.3 头部压缩"></a>5.1.3 头部压缩</h4><p>客户端和服务器共同维护同一张“首部表”，http头部消息会记录在这张表中， 如果已经发过一个请求，第二次请求只会发送修改后的字段，减少冗余数据，降低开销。</p><h4 id="5-1-4-服务器推送"><a href="#5-1-4-服务器推送" class="headerlink" title="5.1.4 服务器推送"></a>5.1.4 服务器推送</h4><p>服务器除了可以响应客户请求外，还能向客户端推送额外的资源。当然客户端是可以不接受的。虽然看上去很简单，其实这个功能及其强大，比如可以通过客户端发送的请求头，列出需要的资源，服务器一次推送过去， 也就只需要一次http的交互，可以推送n个资源。 当然，资源越多响应越慢，这个看情况而用。</p><p>总之http/2协议的能力虽然很强大的，但是http/1.1仍然广泛使用在互联网中。</p><h2 id="6-参考链接"><a href="#6-参考链接" class="headerlink" title="6, 参考链接"></a>6, 参考链接</h2><p><a href="www.ruanyifeng.com/blog/2016/08/http.html">www.ruanyifeng.com/blog/2016/08/http.html</a></p><p><a href="https://www.cnblogs.com/yingsmirk/p/5248506.html" target="_blank" rel="noopener">https://www.cnblogs.com/yingsmirk/p/5248506.html</a></p><p><a href="https://hpbn.co/brief-history-of-http/" target="_blank" rel="noopener">https://hpbn.co/brief-history-of-http/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;这是一篇关于http的历史故事。HTTP 超文本传输协议（HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。本文不重点介绍http协议中的语法和传输协议的实现。我们只是简单入门，了解这些年http协议的变化，和在互联网的浪潮中发挥
      
    
    </summary>
    
      <category term="网络" scheme="https://ipanyiwen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="协议" scheme="https://ipanyiwen.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>n皇后</title>
    <link href="https://ipanyiwen.github.io/2018/07/02/n%E7%9A%87%E5%90%8E/"/>
    <id>https://ipanyiwen.github.io/2018/07/02/n皇后/</id>
    <published>2018-07-02T12:32:45.000Z</published>
    <updated>2018-07-03T07:11:35.814Z</updated>
    
    <content type="html"><![CDATA[<h1 id="n皇后问题-回溯法求解"><a href="#n皇后问题-回溯法求解" class="headerlink" title="n皇后问题-回溯法求解"></a>n皇后问题-回溯法求解</h1><hr><h2 id="1-算法描述"><a href="#1-算法描述" class="headerlink" title="1.算法描述"></a>1.算法描述</h2><p>在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><p><img src="/static/pic01.png" alt="pic"><br><a id="more"></a></p><p>n皇后是由八皇后问题演变而来的。该问题是国际西洋棋棋手马克斯·贝瑟尔于1848年提出：在8×8格的国际象棋上摆放八个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。 高斯认为有76种方案。1854年在柏林的象棋杂志上不同的作者发表了40种不同的解，后来有人用图论的方法解出92种结果。</p><h2 id="2-算法分析"><a href="#2-算法分析" class="headerlink" title="2.算法分析"></a>2.算法分析</h2><p>随着计算机的普及和发展，以前人们无法解决的问题，计算机可以简单计算出来。而且思路十分清晰，那就是暴力求解，遍历所有情况，然后计算出解的个数。</p><h3 id="2-1-回溯法"><a href="#2-1-回溯法" class="headerlink" title="2.1 回溯法"></a>2.1 回溯法</h3><p>按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到目标，就退回一步重新选择，这种走不通就退回再走的技术为回溯法</p><h3 id="2-2-回溯法思路"><a href="#2-2-回溯法思路" class="headerlink" title="2.2 回溯法思路"></a>2.2 回溯法思路</h3><p>用数组模拟棋盘，从第一行开始，依次选择位置， 如果当前位置满足条件，则向下选位置， 如果不满足条件，那么当前位置后移一位。</p><p><img src="/static/pic02.png" alt="pic"></p><p><img src="/static/pic03.png" alt="pic"></p><p>最后一个不满足，回溯到上一行， 选下个位置，继续试探。</p><p>其实并不需要一个n*n的数组，我们只需要一个n长度的数组来存位置。</p><p>表示方式： arr[i] = k; 表示： 第i行的第k个位置放一个皇后。这样一个arr[n]的数组就可以表示一个可行解， 由于回溯，我们就可以求所有解。</p><h3 id="2-3-n皇后回溯求解"><a href="#2-3-n皇后回溯求解" class="headerlink" title="2.3 n皇后回溯求解"></a>2.3 n皇后回溯求解</h3><p>因为八皇后不能在同行，同列， 同斜线。</p><ol><li>每一行放一个皇后，就解决了不在同行的问题。</li><li>在第i行的时候，遍历n列，试探位置。和之前所有行放的位置进行比较。</li><li>比较列：当前列col 不等于 之前 所有列。 即col != arr[i].</li><li>比较斜线， 因为不再同一斜率为1或者-1的斜线。(row - i) / (col - arr[i]) != 1 或 -1<br>可以取巧用绝对值函数: abs(row-i) != abs(col-arr[i])</li></ol><p>我们可以提取比较方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;   <span class="comment">//当前行和列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)  <span class="comment">//比较之前row -1 列。</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(col == arr[i] || abs(row-i) != abs(col-arr[i]))  <span class="comment">//如果在同一列，同一斜线</span></span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>比较函数写完后， 就只剩下回溯过程， 我们采用递归的方式回溯，比较好理解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//当前层  row</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">  <span class="keyword">if</span>(comp(row, i))&#123;</span><br><span class="line">    arr[row] = i;</span><br><span class="line">    <span class="comment">//同样方式遍历下一层。 row + 1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-时间复杂度"><a href="#2-4-时间复杂度" class="headerlink" title="2.4 时间复杂度"></a>2.4 时间复杂度</h3><p> 递归n行， 每次循环 n 列， 比较 0～n-1 次。<br> n * n * (n - 1) / 2.<br> 也就是 O（n^3）. 哇塞，真暴力。</p><h3 id="2-5-空间复杂度"><a href="#2-5-空间复杂度" class="headerlink" title="2.5 空间复杂度"></a>2.5 空间复杂度</h3><p>因为只用了arr[n]的数组，也就是O(n).</p><h2 id="3-代码实现"><a href="#3-代码实现" class="headerlink" title="3.代码实现"></a>3.代码实现</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NQueen</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> n;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> count;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span>[] arr;</span><br><span class="line"><span class="comment">//    private int nn;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.n = n;</span><br><span class="line">  <span class="comment">//      nn = (1 &lt;&lt; n) - 1;</span></span><br><span class="line">        count = <span class="number">0</span>;</span><br><span class="line">        arr = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * row col   i  arr[i]</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> row</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> col</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">Check</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(col == arr[i] || Math.abs(row - i) == Math.abs(col - arr[i])) <span class="comment">//在同一列或者在同一斜线。一定不在同一行</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNQueen</span><span class="params">(<span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (k == n) &#123;   <span class="comment">//求出一种解， count+1</span></span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Check(k, i)) &#123;   <span class="comment">//检查是否满足条件</span></span><br><span class="line">                arr[k] = i;      <span class="comment">//记录</span></span><br><span class="line">                FindNQueen(k + <span class="number">1</span>);   <span class="comment">//递归查找</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args[])</span></span>&#123;</span><br><span class="line">        NQueen nQueen = <span class="keyword">new</span> NQueen(<span class="number">13</span>);</span><br><span class="line">        nQueen.FindNQueen(<span class="number">0</span>);</span><br><span class="line">        System.out.println(nQueen.count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-拓展，位运算-回溯法实现"><a href="#4-拓展，位运算-回溯法实现" class="headerlink" title="4. 拓展，位运算+回溯法实现"></a>4. 拓展，位运算+回溯法实现</h2><p>虽然计算机算的很快，但是上诉方法实在是太慢了， java就更慢了。如何网上就有大佬给出了位运算求解。精妙的不行。</p><h3 id="4-1-算法思路"><a href="#4-1-算法思路" class="headerlink" title="4.1 算法思路"></a>4.1 算法思路</h3><p>我们不再用数组来存储位置，而是用一个整数k，k一开始等于0. 不是普通的0.我们也不比较了，直接用两个整数l和r 记录在斜线在当前行不能走的位置。如果是n皇后， 那么用一个整数<br>nn =  1 &lt;&lt; n 表示结束。</p><p>举个栗子吧： 8皇后问题。</p><p>初始化 那么我们就变成二进制的角度来看这些初始化的数据吧。</p><p>k = 00000000, l = 00000000, r = 00000000; nn = 11111111; (&lt;- 8个0 8个1)  </p><ol><li>k: 每个位置i的0表示没有皇后，1表示在第i个位置放了一个皇后。</li><li>l: 0表示之前所有的列中放的皇后斜率为-1的线上没有涉及这个位置， 1 表示涉及到了，不能放皇后</li><li>r: 同l， 所有斜率为1的线涉及的位置。</li></ol><p>l和r的实现：</p><p>比如k = 00110001.  我要在第4个为位置放一个皇后， 假设l和r都没有涉及这个位置。</p><p>那么这个位置x= 00001000.</p><ol><li>k = (k &amp; x) = 00111001.</li><li>l = (l &amp; x) &lt;&lt; 1.</li><li>r = (r &amp; x) &gt;&gt; 1.</li></ol><p>假设l = 00110001， r = 00100010.下一行，l表示斜率为-1不能放的位置， 那么第i+1行 l 中所有为1的数字都需要向左移动一位，r需要向右移动一位。 l &amp; x 也就是加上当前选中的位置一起移动。</p><h3 id="4-2代码实现"><a href="#4-2代码实现" class="headerlink" title="4.2代码实现"></a>4.2代码实现</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k  当前已走了多少个位置。   l 左斜线不能走的位置， r 右斜线不能走的位置。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FindNQueen</span><span class="params">(<span class="keyword">int</span> k, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k == nn)&#123;</span><br><span class="line">        count++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> z = nn &amp; (~(k | l | r));  <span class="comment">//能走的位置， 和nn取并可以去掉前面多余的1</span></span><br><span class="line">    <span class="keyword">while</span>(z != <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> index = z &amp; (~z+<span class="number">1</span>);   <span class="comment">//最右边的一个1， 即要放皇后的位置。</span></span><br><span class="line">        z -= index;   <span class="comment">//去掉这个位置。</span></span><br><span class="line"></span><br><span class="line">        FindNQueen(k | index, (l|index)&lt;&lt;<span class="number">1</span>, (r|index)&gt;&gt;<span class="number">1</span>);   <span class="comment">//查找下一个。</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-算法分析"><a href="#4-3-算法分析" class="headerlink" title="4.3 算法分析"></a>4.3 算法分析</h3><ol><li>时间复杂度，遍历n行， 每行n列.  O(n^2).  emmm 快了不少。</li><li>空间复杂度，只用了几个变量， O(1).</li></ol><h2 id="5-展望"><a href="#5-展望" class="headerlink" title="5. 展望"></a>5. 展望</h2><p>其实还有其他方式和更快的方式求解，比如位运算+多线程， 还有号称时间复杂度为O(1)，利用数学公式的构造法求解。扶我起来，我要继续学。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;n皇后问题-回溯法求解&quot;&gt;&lt;a href=&quot;#n皇后问题-回溯法求解&quot; class=&quot;headerlink&quot; title=&quot;n皇后问题-回溯法求解&quot;&gt;&lt;/a&gt;n皇后问题-回溯法求解&lt;/h1&gt;&lt;hr&gt;
&lt;h2 id=&quot;1-算法描述&quot;&gt;&lt;a href=&quot;#1-算法描述&quot; class=&quot;headerlink&quot; title=&quot;1.算法描述&quot;&gt;&lt;/a&gt;1.算法描述&lt;/h2&gt;&lt;p&gt;在n×n格的国际象棋上摆放n个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/static/pic01.png&quot; alt=&quot;pic&quot;&gt;&lt;br&gt;
    
    </summary>
    
      <category term="算法" scheme="https://ipanyiwen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ipanyiwen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="回溯" scheme="https://ipanyiwen.github.io/tags/%E5%9B%9E%E6%BA%AF/"/>
    
  </entry>
  
  <entry>
    <title>wordpress使用 Font Awesome 图标在 Firefox 中不显示问题</title>
    <link href="https://ipanyiwen.github.io/2018/06/26/wordpress-e4-bd-bf-e7-94-a8-font-awesome-e5-9b-be-e6-a0-87-e5-9c-a8-firefox-e4-b8-ad-e4-b8-8d-e6-98-be-e7-a4-ba-e9-97-ae-e9-a2-98/"/>
    <id>https://ipanyiwen.github.io/2018/06/26/wordpress-e4-bd-bf-e7-94-a8-font-awesome-e5-9b-be-e6-a0-87-e5-9c-a8-firefox-e4-b8-ad-e4-b8-8d-e6-98-be-e7-a4-ba-e9-97-ae-e9-a2-98/</id>
    <published>2018-06-26T07:41:33.000Z</published>
    <updated>2018-07-01T12:22:23.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题:</strong>  换了个主题后发现一些图标的不显示。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/06/LO43X4C46DIXN8N4ISJ@N6-300x111.png" alt=""> <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/06/QQ图片20180626150908-300x48.png" alt=""> 解决方案： 由于字体跨域导致。 由于我的是apache2服务器。 进入配置文件：</p><pre><code>sudo vim /etc/httpd/conf/httpd.conf </code></pre><p>添加</p><pre><code>Header set Access-Control-Allow-Origin * </code></pre><p>问题解决！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题:&lt;/strong&gt;  换了个主题后发现一些图标的不显示。 &lt;img src=&quot;http://120.78.85.68/wordpress/wp-content/uploads/2018/06/LO43X4C46DIXN8N4ISJ@N6-300x111
      
    
    </summary>
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://ipanyiwen.github.io/2018/05/26/e5-a0-86-e6-8e-92-e5-ba-8f/"/>
    <id>https://ipanyiwen.github.io/2018/05/26/e5-a0-86-e6-8e-92-e5-ba-8f/</id>
    <published>2018-05-26T13:48:56.000Z</published>
    <updated>2018-07-02T06:27:06.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><blockquote><p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。</p></blockquote><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p>将根节点最大的堆叫做最大堆或大根堆，在这颗完全二叉树中,所有根节点都大于两个子节点. <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/05/2018-05-26-21-47-47-的屏幕截图.png" alt=""></p><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>根节点最小的堆叫做最小堆或小根堆。在这颗完全二叉树中,所有根节点都小于两个子节点. <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/05/2018-05-26-21-46-50-的屏幕截图.png" alt=""></p><h4 id="堆的定义如下："><a href="#堆的定义如下：" class="headerlink" title="堆的定义如下："></a>堆的定义如下：</h4><p>n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。 小根堆: (ki &lt;= k2i,ki &lt;= k2i+1)或者 大根堆: (ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>给定一个大根堆的二叉树. 每次将堆顶元素取出, 放入有序集合. 将堆低元素放入堆顶,重新将该树构造大根堆,重复上诉过程,即可得到一个有序集合.</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路:"></a>算法思路:</h4><ol><li>构造大根堆.</li><li>取堆顶元素(即最大值)放入有序集合中, 将堆低元素放入堆顶,此时该二叉树可能不满足堆,故需要重新构建堆.</li><li>重复步骤2,直到构造完成.</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><pre><code>/**   * 调整堆   * @param poi 需要调整的数字位置 *   * @param a 数组-&gt; 模拟堆 *   * @param len 数组长度, 堆元素个数   * */  public static void adjustHeap(int poi, int a[], int len){      int temp = a[poi];      for (int i = poi*2+1; i &lt; len; i=i*2+1) {          if (i+1 &lt; len &amp;&amp; a[i] &lt; a[i+1]) {              i++;          }          if(temp &lt; a[i]){              a[poi] = a[i];              poi = i;          }else {              break;          }      }      a[poi] = temp;  }  /** * 堆排序 *   * @param a 数组-&gt; 模拟堆 *   * @param len 数组长度, 堆元素个数   * */  public static void heapsort(int a[], int len){      for(int i = len/2-1; i &gt;= 0; i--){          adjustHeap(i, a, len);      }      for(int i = len-1; i &gt; 0; i--){          int temp = a[0];          a[0] = a[i];          a[i] = temp;          adjustHeap(0, a, i);      }  }</code></pre><h4 id="构造大根堆分析"><a href="#构造大根堆分析" class="headerlink" title="构造大根堆分析:"></a>构造大根堆分析:</h4><p>由于二叉树的叶子节点数为: n0 = (n+1)/2 //该除2是不会计算小数,也就是计算机中的除2 所以非叶子节点树为: n1 = n - n0 = n/2. //在计算机语言中是n/2 由于数组是从0开始, 所以我们需要构造大根堆时是从n/2 -1 到 0,即构造所有非叶子节点.  </p><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析:"></a>算法分析:</h5><p>时间复杂度: O(nlog(n)) 总时间复杂度: O(nlog(n)) 初始化大根堆时间复杂度分析:</p><p>树的深度: k = log(n)  =&gt; 2^k = n</p><p>  最坏的情况在第i层  有2^(i-1) 个节点, 往下k-i次替换.  所以时间复杂度:<br>s = 2^(i-1) <em> (k-i)  |  i -&gt; (k-1 ~ 1)<br>展开:  s = 2^(k-2) </em> 1 + 2^(k-3) <em> 2 + 2^(k-4) </em> 3 + … + 2^0 <em> (k-1)<br>两边同时乘2:  2s = 2^(k-1)  + 2^(k-2) </em> 2 + 2^(k-3) <em> 3 + … + 2^1 </em> (k-1)<br>2式减1式: s = (2^(k-1) + 2^(k-2) + 2^(k-3) + … + 2^1) - (k-1) =  2*(1-2^(k-1))/(1-2) - (k-1) = 2^k - k - 1<br>所以s的时间复杂度: n - log(n) - 1  =&gt;  O(n)</p><p>总时间复杂度: 循环n-1次,最坏的情况每次都从1到k, 每层都换,也就是log(n)次, 所以时间复杂度为: (n-1) * log(n) 所以总时间复杂度: O(nlog(n)).   空间复杂度:O(1) 稳定性: 不稳定的排序算法.</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h4><p>堆排序可以用来排序, 但大多数时候不如快排 可是当数据量巨大, 如百万级别的时候, 快排的递归调用可能会使堆栈溢出.而堆排序O(1)的空间复杂度,还没有递归调用, 就十分合适了. 还可以用来实现优先队列.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆的定义&quot;&gt;&lt;a href=&quot;#堆的定义&quot; class=&quot;headerlink&quot; title=&quot;堆的定义&quot;&gt;&lt;/a&gt;堆的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象
      
    
    </summary>
    
      <category term="算法" scheme="https://ipanyiwen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ipanyiwen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言_07 内存</title>
    <link href="https://ipanyiwen.github.io/2018/03/21/c-e8-af-ad-e8-a8-80-07-e5-86-85-e5-ad-98/"/>
    <id>https://ipanyiwen.github.io/2018/03/21/c-e8-af-ad-e8-a8-80-07-e5-86-85-e5-ad-98/</id>
    <published>2018-03-20T16:10:45.000Z</published>
    <updated>2018-07-02T06:26:13.547Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性"><a href="#前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性" class="headerlink" title="前言: 程序的执行是放入内存中的,而我们在写代码时定义的变量, 函数等是存储在内存的不同区域. 不同的区域有着不同的特性."></a>前言: 程序的执行是放入内存中的,而我们在写代码时定义的变量, 函数等是存储在内存的不同区域. 不同的区域有着不同的特性.</h4><h3 id="参考资料和网上所说的内存分区大致可以分为两种-分四个区和分五个区"><a href="#参考资料和网上所说的内存分区大致可以分为两种-分四个区和分五个区" class="headerlink" title="参考资料和网上所说的内存分区大致可以分为两种: 分四个区和分五个区."></a>参考资料和网上所说的内存分区大致可以分为两种: 分四个区和分五个区.</h3><h4 id="1-四区-栈区-堆区-全局-静态-区-常量-代码-区"><a href="#1-四区-栈区-堆区-全局-静态-区-常量-代码-区" class="headerlink" title="1.四区: 栈区, 堆区, 全局(静态)区, 常量(代码)区."></a>1.四区: 栈区, 堆区, 全局(静态)区, 常量(代码)区.</h4><h4 id="2-五区-栈区-堆区-全局-静态-区-常量区-代码区"><a href="#2-五区-栈区-堆区-全局-静态-区-常量区-代码区" class="headerlink" title="2.五区: 栈区, 堆区, 全局(静态)区, 常量区. 代码区."></a>2.五区: 栈区, 堆区, 全局(静态)区, 常量区. 代码区.</h4><p>其实这两者就是将最后一个区分为常量区和代码区.我们介绍的话就以五区来介绍吧. 主要将最后的那个区分开理解就好. 当然还有一种分四区: 栈区, 堆区, 数据区, 代码区. 将数据区细分为全局(静态)区, 常量区.虽然这样分很好理解,但是并不那么贴切(个人感觉). 来张图片理解一下(随便百度的): 最上面的计算机内核使用的归操作系统,虽然和我们编写程序没什么关系,但是也要了解以下.</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/1132092356331491654.jpg" alt=""></p><h2 id="内存五区"><a href="#内存五区" class="headerlink" title="内存五区:"></a>内存五区:</h2><h3 id="1-栈区"><a href="#1-栈区" class="headerlink" title="1.栈区:"></a>1.栈区:</h3><p>栈区,是我们最常用到的区域, 因为我们所有的普通局部变量全部存储在这个区.就如我们定义和使用局部变量一样. 在栈区的数据是不需要我们手动去申请和释放内存的. 这个过程全部由编译器帮我们完成,所以我们的局部变量可以直接使用.</p><pre><code>int func(int x, int y){   //传递过来的参数 在栈区    int z = x + y;     //函数内部定义的局部变量在栈区    return z;}int main(){    int a = 3;    //函数内部定义的局部变量在栈区    a += 2;    return 0;}</code></pre><h3 id="2-堆区"><a href="#2-堆区" class="headerlink" title="2.堆区:"></a>2.堆区:</h3><p>堆区,凡是手动malloc realloc calloc, 或者 C++中的new出来的变量都是存储在堆区. 如果学过数据结构或者用过C++的话就会知道, 数据结构中的链表是任意长度的,我们用c实现的话每个节点都是通过malloc函数创建出来的.而C++的话我们new出来的对象都是局部对象, 这些都是我们自己手动申请创建的内存.</p><h4 id="注意-我们手动申请的在堆区的时候-如果我们不手动释放-free-掉这段内存-这段内存会一直占用直到程序结束-手动释放掉内存后切记将该指针置空"><a href="#注意-我们手动申请的在堆区的时候-如果我们不手动释放-free-掉这段内存-这段内存会一直占用直到程序结束-手动释放掉内存后切记将该指针置空" class="headerlink" title="注意: 我们手动申请的在堆区的时候,如果我们不手动释放(free)掉这段内存, 这段内存会一直占用直到程序结束. 手动释放掉内存后切记将该指针置空."></a><em>注意: 我们手动申请的在堆区的时候,如果我们不手动释放(free)掉这段内存, 这段内存会一直占用直到程序结束. 手动释放掉内存后切记将该指针置空.</em></h4><p>当然C++通过new 出来的对象系统会自动调用析构函数释放内存.</p><pre><code>int *func(int x, int y){  //x y, 是在栈区    int *p = malloc(4);  //p所指向的内存就存放在堆区.    *p = x+y;    return p;}int main(){    int *p = NULL;    p = func(3, 5);    printf(&quot;%d\n&quot;, *p);    free(p); //使用完后释放内存, 并将p置空    p = NULL;    //后续代码操作    return 0;}</code></pre><h3 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3.全局(静态)区:"></a>3.全局(静态)区:</h3><p>全局(静态)区:故名思义,全局变量和静态变量(static)存放的在这个区.这个区域也叫可读写区, 分为.data和.bss两部分, 1 .data段(初始化全局|静态变量), 所有初始化了的全部变量存放的区域.则为数据分配空间，数据保存在目标文件中。 2 .bss段(未初始化全局|静态变量), 所有未初化的全部变量存放的区域.不给该段的数据分配空间，只是记录数据所需空间的大小。 <em>注意: 如果我们定义了一个全部整型变量并赋予了初始值0, 如果我们不给其赋值编译器也会在使用时赋予初始值0, 为了优化会将其放入.bss段, 当作未初始化处理.(看到有人的帖子这样说的,但是我不会验证 TAT!)</em> 附上帖子地址: <a href="http://blog.csdn.net/u010154760/article/details/46552303" target="_blank" rel="noopener">http://blog.csdn.net/u010154760/article/details/46552303</a></p><pre><code>int a;      //全局(静态)区//int a = 0;  //据说都是在.bss段int b = 2; //全局(静态)区,  .data段void static fun_sta(){   //这个函数是存放在代码区的. }void func(){    static int a = 0;  //全局(静态)区.  额,这个应该也是在.bss吧.不知道有没有好心人告知一波...    static int b = 1; //全局(静态)区.  .data段}int main(){    static int a = 3;  //全局(静态)区 .data段    return 0;}</code></pre><h3 id="4-常量区"><a href="#4-常量区" class="headerlink" title="4.常量区:"></a>4.常量区:</h3><p>常量区: (也叫文字常量区)我们在程序中使用的一些整型常量, 浮点型常量, 还有一个很容易误会的字符串常量都是存放在常量区. 举个简单的例子: int a = 4; 我们知道a是存放在栈区的, &amp;a的地址就是栈区的地址, 但是4却是存放在常量区.画图帮助理解.<br><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/changliangqu.png" alt=""> </p><p>普通的常量很好理解, 但是字符串有点特殊.举个例子.</p><pre><code>int main(){    char *s = &quot;abc&quot;;   //字符串    char *s1 = &quot;abc&quot;;   //字符串    char s2[] = &quot;abc&quot;;  //字符串数组    printf(&quot;%p\n&quot;, s);    printf(&quot;%p\n&quot;, s1);    printf(&quot;%p\n&quot;, s2);    return 0;}</code></pre><p>输出结果:</p><pre><code>panyiwen@god:~/temp$ ./a.out 0x4006b40x4006b40x7ffe50893e90</code></pre><p><em>可以看出指针s 和 s1指向的是同一个地址, 而s2和前两个都不同. 原因就是: s 和 s1 都是指向常量区的地址, 常量区只有一个字符串”abc”, 而s2是一个普通的局部变量数组, 那么s2就是存储在栈区的一个字符串</em> 画图理解: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/string.png" alt=""></p><h3 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5 代码区:"></a>5 代码区:</h3><p>代码区: 故名思义, 所有的代码是存放在这里.而且是编译后的二进制代码.当然这个区是由操作系统直接控制.</p><h4 id="代码区和常量区因为都是不可修改的-所以这两个区也被合并在一块称之为只读区"><a href="#代码区和常量区因为都是不可修改的-所以这两个区也被合并在一块称之为只读区" class="headerlink" title="代码区和常量区因为都是不可修改的, 所以这两个区也被合并在一块称之为只读区."></a><em>代码区和常量区因为都是不可修改的, 所以这两个区也被合并在一块称之为只读区.</em></h4><p>再放入一张横向图片供参考.<br><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/1356942710_5027.jpg" alt=""> </p><p>鸣谢:<br><a href="http://blog.csdn.net/czg13548930186/article/details/52766606" target="_blank" rel="noopener">http://blog.csdn.net/czg13548930186/article/details/52766606</a><br><a href="http://blog.csdn.net/androidxiaogang/article/details/50383516" target="_blank" rel="noopener">http://blog.csdn.net/androidxiaogang/article/details/50383516</a><br><a href="http://blog.csdn.net/u010672206/article/details/46946593" target="_blank" rel="noopener">http://blog.csdn.net/u010672206/article/details/46946593</a> </p><p>希望能让你能有所收获, 不对的地方还请多多指教.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性&quot;&gt;&lt;a href=&quot;#前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性&quot; clas
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_06 指针</title>
    <link href="https://ipanyiwen.github.io/2018/03/20/c-e8-af-ad-e8-a8-80-06-e6-8c-87-e9-92-88/"/>
    <id>https://ipanyiwen.github.io/2018/03/20/c-e8-af-ad-e8-a8-80-06-e6-8c-87-e9-92-88/</id>
    <published>2018-03-19T18:37:00.000Z</published>
    <updated>2018-07-02T06:25:58.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><strong>指针</strong>（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p></blockquote><p>我们都知道, 在计算机语言中, 变量是储存在计算机的内存中的, 所以C程序想要访问得到变量必须知道储存在计算机内存中的什么位置, 在C程序中用来存储这个位置的变量就是指针.</p><h2 id="指针的定义方法"><a href="#指针的定义方法" class="headerlink" title="指针的定义方法:"></a>指针的定义方法:</h2><pre><code>int *p = NULL;   //定义一个整型指针.char *p1 = NULL; //定义一个char型指针double *p2 = NULL;  //定义一个浮点型指针</code></pre><p>定义指针和定义一个变量一样, 不过变量名前面加上一个星号(*), 表示这是一个什么类型的指针.</p><h3 id="取地址符-amp-和指针运算符"><a href="#取地址符-amp-和指针运算符" class="headerlink" title="取地址符: &amp; 和指针运算符 *"></a>取地址符: &amp; 和指针运算符 *</h3><h4 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符 &amp;:"></a>取地址符 &amp;:</h4><pre><code>int a=3;int *p = &amp;a;   //取a的地址, 赋值给一个同类型的指针scanf(&quot;%d&quot;, &amp;a);  //我们输入一个整数需要存放进内存,所以我们必须知道将这个整数存放在内存的什么位置(地址).</code></pre><h4 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符 *:"></a>指针运算符 *:</h4><pre><code>int a = 3;int *p = &amp;a;    //定义一个指针p,并将a的地址赋值给p, 这里的* 只是告知编译器定义的是一个指针变量.//我们取得a的地址给了p,但是我们怎么取得a的值呢?  --指针运算符int b = *p+3;    //效果相当于: int b = a + 3;  也相当与 int b = *&amp;a + 3;</code></pre><p>看到这里其实可以发现,我们平时定义的int a = 3; a = a + 3; 这个a被C语言简化隐藏起来了 *(&amp;a), 找到a的地址, 然后取出该地址中存放的值.再对这个值进行操作.</p><h2 id="指针和指针变量"><a href="#指针和指针变量" class="headerlink" title="指针和指针变量"></a>指针和指针变量</h2><p>1.指针:上面我们知道指针其实就是一段地址. 一个变量int a, 那么a的内存地址就是指针. 2.指针变量: 用来存放指针(地址)的变量. 举个栗子:</p><pre><code>int a = 4;int *p = &amp;a;   //取a的地址;</code></pre><p>这个p就是指针变量, a的地址(&amp;a)就是指针. 也就是指针变量指向的地址就是指针,存放这个地址的变量就是指针变量.</p><h4 id="重点-指针变量中存放的地址-这个地址是指变量的首地址"><a href="#重点-指针变量中存放的地址-这个地址是指变量的首地址" class="headerlink" title="重点: 指针变量中存放的地址, 这个地址是指变量的首地址."></a><em>重点: 指针变量中存放的地址, 这个地址是指变量的首地址.</em></h4><pre><code>int a = 3;       //整型占四个字节. 如果a在内存中的位置是1000 ~ 1003int *p = &amp;a;   // 那么p = 1000, 因为是整型指针变量, 所以系统就知道1000~1003都是p所指向的东西.</code></pre><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><h3 id="指针变量的地址"><a href="#指针变量的地址" class="headerlink" title="指针变量的地址"></a>指针变量的地址</h3><p>我们知道指针变量也是存放在内存中的一个变量,那么存放在内存中,就有地址,这个就是指针的地址. int *p = &a; 那么p == &a; 指针变量的地址: &p;</p><h3 id="指向指针的指针-1"><a href="#指向指针的指针-1" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>我们通常定义的指针: int a = 3; int *p = &a;这个p指向的是整型变量a的地址. 那么指针变量p的地址: &amp;p用什么来存.</p><pre><code>int a = 3;int *p = &amp;a;//不能用 int *p1 = &amp;p;会报错,正确的方法: int **p1 = &amp;p;    //p1就是指向指针的指针.//所以我们得到p1, 怎么得到3呢? // *p1 == p == &amp;a// *(*p1) == *p == a == 3, 括号可以省略int b = **p1 + 3;</code></pre><h2 id="数组与指针的关系"><a href="#数组与指针的关系" class="headerlink" title="数组与指针的关系"></a>数组与指针的关系</h2><p>我们知道数组是一系列相同数据的集合, 我们通常定义一个数组: int a[4] = {1, 2, 3, 4}; 然后我们就可以通过下标任意访问数组中的任意一个元素, a[0] == 1, a[1] == 2. 但其实数组名就是一个有着特殊用法的指针. 举个例子</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int b = a[0] + 2;  //访问数组中的第一个元素.int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;第一个元素的地址: %p\n&quot;, p);  //打印第一个元素的地址.printf(&quot;a的地址: %p\n&quot;, a);  //打印aprintf(&quot;p指向的地址的值: %d\n&quot;, *p); //打印p指向的地址的值printf(&quot;a指向的地址的值: %d\n&quot;, *a); //打印a指向的地址的值</code></pre><p>结果:</p><pre><code>panyiwen@god:~/temp$ ./a.out 第一个元素的地址: 0x7ffc259b5b20       a的地址: 0x7ffc259b5b20p指向的地址的值: 1a指向的地址的值: 1</code></pre><p>我们会发现数组a其实就是一个指向数组第一个元素首地址的指针.因为我们定义了int a[4]; 所以系统就会为a开辟一个连续的占4个整型的内存.a就是这段内存的开始地址, 例子:</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;%d\n&quot;, a[1]);  //输出第二个元素printf(&quot;%d\n&quot;, *(p+1));  //同样可以输出第二个元素  //输出结果都是2//(指针类型+1)指加一个同样类型的长度, int 类型的p+1 相当于后移动4位, char 类型的p+1就相当于移动了1位</code></pre><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/point.png" alt=""> 假设a的地址就是1000, 那么p+1就是1004, 也就是第二个元素的首地址, 这样我们就应该明白了,所谓的一对中括号[]运算符, 就是指针走到第n个位置并取出里面的值.只是c语言进行了封装.举个例子验证一下:</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;%d\n&quot;, a[1]);  //输出第二个元素printf(&quot;%d\n&quot;, p[1]);  //同样可以输出第二个元素  相当于*(p+1)</code></pre><p>一个指针也同样可以使用[]运算符. 输入结果和之前是一样的.</p><h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针:"></a>二维数组与指针:</h4><p>二维数组:int a[2][2] = { {1, 2}, {3, 4}}; 在内存中仍然是开辟4个连续的int型空间.但是和int a[4] = {1, 2, 3, 4} 在存储上没什么区别, 但是意义却不同. int a[2][2]; 可以理解为: a[0] -&gt; {1, 2} a[1] -&gt; {3, 4} a[0], a[1] 均为指针变量. 而a - &gt; int *tmp[] = {a[0], a[1]}; tmp为存放指针的数组, 所以a是一个指向指针数组的指针.</p><h4 id="重点-但是a中存放的并不是一个新的指针数组-tmp-所在的地址-而是原来数组的首位地址-所以如果我们用int-p来指代a是不对的"><a href="#重点-但是a中存放的并不是一个新的指针数组-tmp-所在的地址-而是原来数组的首位地址-所以如果我们用int-p来指代a是不对的" class="headerlink" title="重点: 但是a中存放的并不是一个新的指针数组(tmp)所在的地址, 而是原来数组的首位地址,所以如果我们用int **p来指代a是不对的."></a><em>重点: 但是a中存放的并不是一个新的指针数组(tmp)所在的地址, 而是原来数组的首位地址,所以如果我们用int **p来指代a是不对的.</em></h4><pre><code>//所以下面两个其实是不一样的.int a[2][2] = { {1, 2}, {3, 4}};int **p = a;   //a是第一个元素的首地址, 所以a == &amp;a[0][0]//所以*p == *(&amp;a[0][0]) == a[0][0] = 1//所以**p == *1, 取地址为1中的数据, 就会出现错误.//正确用法其实是: int *p = a; // 然后根据二维数组的位置直接取就可以了.int b = *(p+1*2+0)+1; // 相当于 int b = a[1][0] + 1;//而a就是我们理解指向指针数组的指针. printf(&quot;%p\n&quot;, *(a+1));printf(&quot;%p\n&quot;, a[1]);//这两者是一样的.</code></pre><h2 id="结构体与指针"><a href="#结构体与指针" class="headerlink" title="结构体与指针"></a>结构体与指针</h2><p>结构体对于C来说非常重要,学C不可避免的要学习结构体, 而结构体和指针也是息息相关的.</p><blockquote><p>C语言结构体内嵌指针实现面向对象, C语言是面向过程的，但是用C语言写出的linux系统是面向对象的。 非面向对象的语言，也可以实现面向对象的代码。只是说用面向对象的语言来实现面向对象要更加简单、直观一些.而C语言实现起来复杂而已.</p></blockquote><h4 id="结构体中的指针"><a href="#结构体中的指针" class="headerlink" title="结构体中的指针:"></a>结构体中的指针:</h4><p>在结构体内部定义指针, 和普通指针一样使用.</p><pre><code>struct ln{    int *num;    //定义一个结构体中的指针.      };</code></pre><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针:"></a>结构体指针:</h4><p>一个结构体类型的指针,用法和普通结构体差不多,不过访问元素用’-&gt;’ 记得先分配内存再使用!</p><pre><code>struct node{    int data;   //普通整型    int *next;  //结构体内部指针.} *no;  //可以在此处定义一个全局的结构体指针变量.//在main中的定义:int main(){    struct node *mynode;   //定义在main中的局部结构体指针变量    //指针访问内部元素时候是用-&gt;, 使用前记得先申请一个内存,    no = (struct node *)malloc(sizeof(struct node));      no-&gt;data = 1;      //或者    struct node no1；  //定义一个非指针类型.    mynode = &amp;no1;    mynode-&gt;data = 2;     return 0;}</code></pre><h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h2><h4 id="传递指针参数"><a href="#传递指针参数" class="headerlink" title="传递指针参数:"></a>传递指针参数:</h4><p>我们都知道, 函数是可以传递参数的, 如果我们以指针(地址)为参数传递呢？ 其实这就是指针优秀的地方,我们普通参数的传递,都是拷贝一份数据传给函数的形参.这就涉及到了一个很有名的例子.交换两个数.</p><pre><code>void swap(int a, int b){    int t = a;    a = b;    b = t;}int main(){    int a = 1, b = 2;    swap(a, b);    printf(&quot;a=%d, b=%d&quot;, a, b);   //a,b并没有交换. 原因就是上面所说的数据是拷贝一份传给函数的, 实际上的a, b并没有变.    return 0;}</code></pre><p>如果我们是传递指针参数</p><pre><code>void swap(int* a, int* b){    int t = *a;    *a = *b;    *b = t;}int main(){    int a = 1, b = 2;    swap(&amp;a, &amp;b);    printf(&quot;a=%d, b=%d&quot;, a, b);   //a,b交换了. a, b地址传递过去, 那么对于a, b的修改自然影响到了原来的a, b.    return 0;}</code></pre><p>这个例子在很多书上,百度都会有, 解释的比我要详细很多, 不懂的可以百度一下.所以我们传递一个数组上去时候, 传递的是数组名, 其实也就是一个指针变量, 所以函数中对数组的修改会影响到原来的数组. 指针的好处就呼之欲出了, 如果我们的数据很多很大,我们传递一个数据上去, 不需要拷贝一份.只需要一个指针, 4个字节, 8个字节就可以得到数据.加快速度节省空间.只是需要程序员考虑指针会修改原来的数据.</p><h4 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h4><p>返回值是一个指针的函数, 被称为指针函数.</p><pre><code>int *func(){   //返回类型后加一个*     int *p = malloc(4);   //申请堆区的内存. 使用完记得释放.    return p;   //返回值一定要是同类型的指针(地址).}</code></pre><p>这样的函数就称为指针函数. 一般是在函数中申请堆区的内存.因为如果是定义一个普通的变量, 在栈区, 由系统自动释放, 那么在函数调用完就释放了. 当然也可以声明为static,放入静态(全局)区.</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>指向函数的指针变量, 其本质是一个指针变量. 其实函数也是一个存储在计算机内存中的(代码区), 既然是在内存中, 就有地址. 写法: 返回值类型 (*函数名) (参数); 举个例子:</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;}int main(){    int (*pmax)(int, int);  //声明一个函数指针    pmax = max;  //赋值    // pmax = &amp;max;  //也可以这样写.    int z = pmax(3, 4);    // int z = (*pmax)(3, 4);  //也可以这样写    printf(&quot;%d\n&quot;, z);    //输出4    return 0;}</code></pre><p>函数名其实就是函数在内存中的首地址, 知道这个就可以给函数指针赋值.由于函数指针也是一个变量, 所以我们的struct中也就可以放函数指针,使得结构体也可以调用方法.</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;}struct ln{    int data;    int (*pmax)(int, int);  //声明一个函数指针};int main(){    struct ln t;    t.pmax=max;    printf(&quot;%d\n&quot;,t.pmax(3, 4));  //结构体调用方法.    return 0;}</code></pre><p>感谢: <a href="http://nevel.cnblogs.com/p/6370264.html" target="_blank" rel="noopener">http://nevel.cnblogs.com/p/6370264.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（poin
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_05 函数详解</title>
    <link href="https://ipanyiwen.github.io/2018/02/12/c-e8-af-ad-e8-a8-80-05-e5-87-bd-e6-95-b0/"/>
    <id>https://ipanyiwen.github.io/2018/02/12/c-e8-af-ad-e8-a8-80-05-e5-87-bd-e6-95-b0/</id>
    <published>2018-02-11T19:14:34.000Z</published>
    <updated>2018-07-02T06:25:33.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>“函数”是从英文function翻译过来的，其实，function在英文中的意思即是“函数”，也是“功能”。从本质意义上来说，函数就是用来完成一定功能的。这样对函数的概念就很好理解了，所谓函数名就是给该功能起个名字，如果该功能是用来实现数学运算的，就是数学函数。</p></blockquote><h2 id="函数的写法"><a href="#函数的写法" class="headerlink" title="函数的写法"></a>函数的写法</h2><pre><code>返回类型 函数名(参数1, 参数2, ... 参数n)//参数可以不写{    //函数体    ....    return 返回类型; //如果返回类型为void 可以没有return.}</code></pre><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>每个C语言程序至少有一个函数,我们常常用main()函数, 也称之为主函数, 但是C语言的程序的主函数是不是一定叫main呢? 答案当然是否定的, 操作系统在执行main函数之前, 调用了其他代码, 这些代码就有初始化main函数所需的运行环境,而负责初始化main函数的这个函数就称之为入口函数/入口点.而入口函数规定的C程序的主函数就是main, 那么我们当然可以找到这个文件,修改主函数名.</p><h3 id="main函数的返回值"><a href="#main函数的返回值" class="headerlink" title="main函数的返回值"></a>main函数的返回值</h3><p>main函数的返回值一般有两种写法 1.<code>void main</code>2.<code>int main</code> 但是这前者最好不要使用, 不仅仅是有些编译器不支持.还因为操作系统对于一个程序的正常或者执行异常都是整型,如果程序返回 0 表示程序正常执行, 如果返回其他整型,执行异常.那么可以说<code>void main</code>就是一种不恰当的写法. int main的返回值为0或者不为0的程序的执行结果其实都一样,但为什么一定要返回0呢? 举个例子:</p><pre><code>//test.c    #include &lt;stdio.h&gt;    int main(){        printf(&quot;hello &quot;);        return 0;    }//test1.c    #include &lt;stdio.h&gt;    int main(){        printf(&quot;world!\n&quot;);        return 0;    }执行test 和 test1 &amp;&amp;运算符是指执行成功&amp;&amp;前面的便执行后面的, 如果执行前面失败,后面便不会执行.panyiwen@god:~/temp$ ./test &amp;&amp; ./test1hello world!</code></pre><p>如果我们将第一个test.c的返回值改为<code>return 1;</code>执行结果:</p><pre><code>panyiwen@god:~/temp$ ./test &amp;&amp; ./test1hello panyiwen@god:~/temp$</code></pre><p>只输出hello , 没有world和换行.也就是第二个test1.c没有执行.原因便是第一个程序的返回值是1,系统认为该程序没有执行成功.所以不会执行第二个test1</p><h3 id="main函数的三种写法-两种"><a href="#main函数的三种写法-两种" class="headerlink" title="main函数的三种写法(两种)"></a>main函数的三种写法(两种)</h3><h4 id="1-int-main-void-括号中的void可以不写"><a href="#1-int-main-void-括号中的void可以不写" class="headerlink" title="1.int main(void) //括号中的void可以不写"></a>1.int main(void) //括号中的void可以不写</h4><h4 id="2-int-main-int-argc-char-argv"><a href="#2-int-main-int-argc-char-argv" class="headerlink" title="2.int main(int argc, char *argv[])"></a>2.int main(int argc, char *argv[])</h4><h4 id="3-int-main-int-argc-char-argv-char-envp-不建议使用-因为第三个参数只是类unix系统的拓展"><a href="#3-int-main-int-argc-char-argv-char-envp-不建议使用-因为第三个参数只是类unix系统的拓展" class="headerlink" title="3.int main(int argc, char argv[], char envp[]) //不建议使用, 因为第三个参数只是类unix系统的拓展"></a>3.int main(int argc, char <em>argv[], char </em>envp[]) //不建议使用, 因为第三个参数只是类unix系统的拓展</h4><p>其实也就是main函数中可以不写参数, 写两个参数, 写三个参数. 因为是参数,所以名称可以自己取,也可以就用上述名称.</p><h4 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h4><ol><li><code>int argc</code> 整型参数, argc = 1+输入的参数个数, 系统自动赋值, 无需我们写, 1 为程序的名称.</li><li><code>char *argv[]</code> 字符串数组, argv[0] 表示程序的名称, argv[1]~argv[argc-1]代表我们传入的参数.</li><li><code>char *envp[]</code> 字符串数组, 表示系统的环境变量</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">    int main(int argc, char \*argv\[\], char \*envp\[\])&#123;</span><br><span class="line">        int i;</span><br><span class="line">        printf(&quot;%d\\n\\n&quot;, argc);</span><br><span class="line">        for (i = 0; i &amp;lt; argc; i++)&#123;</span><br><span class="line">            printf(&quot;%s\\n&quot;, argv\[i\]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">        for (i = 0; envp\[i\] != NULL; i++)&#123;</span><br><span class="line">            printf(&quot;%s\\n&quot;, envp\[i\]);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们执行这段程序, 并输入参数hello world, 部分输出结果, 因为系统环境变量太多.</p><pre><code>panyiwen@god:~/temp$ ./test hello world3./test hello worldXDG_VTNR=7 XDG_SESSION_ID=c2 CLUTTER_IM_MODULE=xim XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/panyiwen GPG_AGENT_INFO=/home/panyiwen/.gnupg/S.gpg-agent:0:1 SHELL=/bin/bash TERM=xterm-256color ...</code></pre><p>我们可以看到, argc = 3 执行的程序名称+两个参数 argv = {“./test”, “hello”, “world”}; 而envp则全是系统环境变量key=value的字符串. 那么我们知道系统环境变量有什么用? 我们可以得到环境变量配置的一些参数来完成我们需要的功能,但是不建议推荐使用第三个参数传入,因为拓展性不强, 我们可以通过C语言的<code>#include &lt;stdlib.h&gt;</code>库中的函数来得到和设置删除系统环境变量.这样在不同系统上的使用方式就是一致的.</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><blockquote><p>C语言库函数是把自定义函数放到库里，是别人把一些常用到的函数编完放到一个文件里，供程序员使用。程序员用的时候把它所在的文件名用#include&lt;&gt;加到里面就可以了（尖括号内填写文件名），例如<code>#include &lt;math.h&gt;</code>。</p></blockquote><p>库函数也就是一些程序员大牛们,他们将一些我们常用的函数,写到文件里面供我们调用,每次计算机语言的更新,除了一些语法的更新外,很多也是加入一些别的优秀的代码文件加入库中. 说到库函数,我们就不得不提<code>#include &lt;stdio.h&gt;</code> 我们平常写的几乎所有的C程序的开头都会加上这么一句,标准输入输出.那么我们就来介绍以下stdio.h.</p><h3 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h3><blockquote><p>stdio 就是指 “standard input &amp; output”（标准输入输出） 所以，源代码中如用到标准输入输出函数时，就要包含这个头文件！</p></blockquote><h5 id="引用方法-include-lt-stdio-h-gt"><a href="#引用方法-include-lt-stdio-h-gt" class="headerlink" title="引用方法: #include &lt;stdio.h&gt;"></a>引用方法: <code>#include &lt;stdio.h&gt;</code></h5><hr><blockquote><p>stdio.h所包含的函数： 文件访问: fopen,freopen,fflush,fclose 二进制输入/输出: fread, fwrite 非格式化输入/输出: fgetc/getc, fputc/putc, ungetc, fgets ,fputs 格式化输入/输出: scanf/fscanf/sscanf ,printf/fprintf/sprintf, perror 文件定位: ftell, fseek, fgetpos ,fsetpos, rewind 错误处理: feof, ferror 文件操作: remove, rename, tmpfile</p></blockquote><p>大名鼎鼎的EOF 也是宏定义在stdio.h中, 一般编译器定义是: <code>#define EOF -1</code>, 我们常用的scanf, printf 函数都是写在stdio.h中.</p><h3 id="scanf函数和printf函数"><a href="#scanf函数和printf函数" class="headerlink" title="scanf函数和printf函数:"></a>scanf函数和printf函数:</h3><blockquote><p>用 法: int scanf(char *format[,argument,…]); 用 法: int printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p></blockquote><p>我们知道scanf是格式化输入, 调用此函数,我们在计算机的键盘中输入的字符串会传化为相对应的格式,储存到变量中, 并返回一个整数,代表成功输入了多少个. printf是格式化输出, 输出内容到显示器(终端) 返回值是输出字符的个数，若出错，则返回负数。 . 例子:</p><pre><code>int num = scanf(&quot;%f %d&quot;, &amp;a, &amp;b);printf(&quot;a=%f, b=%d, num = %d\n&quot;, a, b, num);</code></pre><p>分析:上面的例子,如果我们正常输入<code>11.2 2</code>,那么函数就会返回一个2表示我们输入成功输出<code>a=11.200000, b=2, num=2</code>, 如果我们输入<code>11.2 a</code>那么就会将11.2 赋值给 a, 但是’a’无法赋值给b, 输入就会失败, 输出<code>a=11.200000, b=517694128, num=1</code>b被随机赋予了一个值, 成功输入一个.如果是<code>a 11</code>那么返回值就是0了,a,b都会被随机赋值. 小知识: 我们知道一个变量是要在内存中开辟一段内存的, 变量储存的值是储存在内存中, &amp;为取地址符,我们要存值, 必须知道变量的地址. 我们平时用的a 其实是 <em>&amp;a 先取出地址再得到内存中的值, 为了方便将</em>&amp;省略. 但是如果用的多的人就会发现scanf有一些很神奇的事情发生,举几个例子:</p><pre><code>scanf(&quot;%d %lf&quot;, &amp;a, &amp;b);scanf(&quot;%s&quot;, ch);scanf(&quot;%d%c&quot;,&amp;a, &amp;c);</code></pre><p>我们对其输出, 第一个我们输入<code>11.234 12.3</code>,结果: <code>a=11 b=0.234000</code> 第二个我们输入<code>Hello World !!!</code>, 结果: <code>Hello</code> 第三个我们输入<code>16 c</code>, 结果:<code>a=16 c=&#39; &#39;</code> 我们其实明白scanf输入浮点型给整型会被强制转换, 字符串%s是不能接受空格的, 如果我们没有规定分隔符是什么,一般默认是空格, 但是输入的空格会被%c接收,所以c=’ ‘,等等很多有意思的点, 那么我们就来看看这个理由吧.先引入点知识点:</p><h3 id="stdin-stdout-stderr的简单介绍"><a href="#stdin-stdout-stderr的简单介绍" class="headerlink" title="stdin, stdout, stderr的简单介绍:"></a>stdin, stdout, stderr的简单介绍:</h3><p>1.stdin, 标准输入流: 通常是键盘输入. 2.stdout, 标准输出流: 输出到屏幕. 3.stderr, 标准错误流: 无缓冲.输出到屏幕. 一般是错误信息. 全缓冲: 直到文件结束或者手动清空缓存,才清空缓冲. 行缓冲: 遇到回车或者换行, 或者文件结束, 清空缓冲</p><blockquote><p>ISO C规定： 当且仅当stdin和stdout不指向交互式设备时，他们才是全缓冲。 stderr决不会是全缓冲。 Linux系统默认： stderr是不带缓冲的。 若流指向终端设备，则是行缓冲，否则为全缓冲。</p></blockquote><p><strong>所以在c语言中stdin和stdout是行缓冲, 我们的scanf和printf函数就是使用了stdin和stdout, 而stdin和stdout就是写在stdio中的.本质就是系统帮我们打开了两个文件句柄. 我们输入的数据就储存在stdin那个文件中, 输出的数据就存储在stdout文件中, 我们调用scanf和printf就是在文件中取数据, 进行输入和输出.</strong> 第一个例子<code>scanf(&quot;%d %lf&quot;, &amp;a, &amp;b);</code> 我们就是从缓冲区stdin 也就是字符串取出<code>11</code> 赋值给a 取出<code>.234</code>赋值给b. 所有有关这些奇特的现象就是和stdin和stdout有关. <strong>scanf 也就是 int fscanf(stdin, const char *format, [argument…]); 遇到换行或空格结束</strong> <strong>printf 也就是int fprintf( stdout, const char *format, [ argument ]…);</strong> 其他的库函数也就是大同小异,主要是知道怎么用的就好.</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>在库函数不满足我们的需求的时候, 我们又不想把所有代码都写在主函数里面, 那样不仅丑,而且可读性,复用性都很差.那么我们就需要自定义函数,来满足我们的需要</strong> 写法和main函数一样</p><pre><code>返回值类型 函数名(参数1, 参数2 ...)//可不写{    //函数体    ...    return 返回值;}</code></pre><p>举个例子, 比大小, 返回最大值:(虽然库函数中有)</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;   //三目运算符 等价与 if(a &gt; b) {return a;} else{ return b;}}int main(){    int a = 100, b = 120;    int maxnum;    maxnum = max(a, b); //调用max函数 返回两个数最大的那个    return 0;}</code></pre><p>C语言中需要注意的是函数要么写在执行前面, 要么是需要声明(告诉计算机有这个函数), 要不然找不到. 也就是掉个位置:</p><pre><code>int main(){    int a = 100, b = 120;    int maxnum;    int max(int, int);  //使用前需要声明有这个函数  只要使用前声明就好,也就是可以写在int main()的上面也可以.    maxnum = max(a, b); //调用max函数 返回两个数最大的那个    return 0;}int max(int a, int b){    return a &gt; b ? a : b;   //三目运算符 等价与 if(a &gt; b) {return a;} else{ return b;}}</code></pre><p>声明也就是告诉计算机,如果在这之前没找到这个函数没关系,先别报错,我的函数在下面.</p><p>友情链接:<br><a href="http://blog.csdn.net/Crazy_Tengt/article/details/72717144" target="_blank" rel="noopener">http://blog.csdn.net/Crazy_Tengt/article/details/72717144</a><br><a href="http://blog.csdn.net/q565220/article/details/49951885" target="_blank" rel="noopener">http://blog.csdn.net/q565220/article/details/49951885</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“函数”是从英文function翻译过来的，其实，function在英文中的意思即是“函数”，也是“功能”。从本质
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_04 三种程序结构 顺序, 选择(分支), 循环结构</title>
    <link href="https://ipanyiwen.github.io/2018/02/06/c-e8-af-ad-e8-a8-80-04-e4-b8-89-e7-a7-8d-e7-a8-8b-e5-ba-8f-e7-bb-93-e6-9e-84-e9-a1-ba-e5-ba-8f-e9-80-89-e6-8b-a9-e5-88-86-e6-94-af-e5-be-aa-e7-8e-af-e7-bb-93-e6-9e-84/"/>
    <id>https://ipanyiwen.github.io/2018/02/06/c-e8-af-ad-e8-a8-80-04-e4-b8-89-e7-a7-8d-e7-a8-8b-e5-ba-8f-e7-bb-93-e6-9e-84-e9-a1-ba-e5-ba-8f-e9-80-89-e6-8b-a9-e5-88-86-e6-94-af-e5-be-aa-e7-8e-af-e7-bb-93-e6-9e-84/</id>
    <published>2018-02-06T10:31:48.000Z</published>
    <updated>2018-07-02T06:25:01.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构；</p><p>顺序结构，从头到尾一句接着一句的执行下来，直到执行完最后一句；</p><p>选择结构，到某个节点后，会根据一次判断的结果来决定之后向哪一个分支方向执行；</p><p>循环结构，循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，关键在于根据判断的结果，来决定循环体执行多少次。C语言循环控制语句是一个基于C语言的编程语句，该语句主要有while循环语句、do-while循环语句和for循环语句来实现循环结构。</p><p>但是三种结构并不是彼此孤立 循环中可以有顺序, 选择(分支).  顺序中可以有选择,可以有循环. 选择中也可以有顺序有循环. 一段程序代码往往是这三者相互结合组成的.</p><h2 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h2><p> C语言的顺序结构顾名思义, 就是程序自上而下执行, 没有分支,也没有循环.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 3, b = 2;</span><br><span class="line">    int sum = a+b;</span><br><span class="line">    printf(&quot;a+b=%d\\n&quot;, sum);    //输出a+b的和</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上述代码, 程序顺序执行求和a+b并输出, 没有循环也没有分支, 所以上述代码就是一个顺序结构.</p><p><img src="/wordpress/wp-content/uploads/2018/02/20180206015153_85801.png" alt=""></p><h2 id="2-选择-分支-结构"><a href="#2-选择-分支-结构" class="headerlink" title="2.选择(分支)结构"></a>2.选择(分支)结构</h2><p>C语言选择结构用于判断给定的条件，根据判断的结果来控制程序的流程。</p><p>在C语言中, 选择结构有两种: 1. if-else语句,  2. switch-case语句;</p><h3 id="1-if-else-语句"><a href="#1-if-else-语句" class="headerlink" title="1) if-else 语句"></a>1) if-else 语句</h3><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;</span><br><span class="line">    //满足条件1执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;else if(条件2)&#123;</span><br><span class="line">    //不满足条件1, 满足条件2执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //即不满足条件1也不满足条件2 执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子, 成绩评级.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int score = 78; //模拟输入成绩</span><br><span class="line"></span><br><span class="line">    if (score &gt;= 90)&#123;  //成绩 大于90 A</span><br><span class="line">        printf(&quot;A&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 80 &amp;&amp; score &lt; 90)&#123; // 80-89 B</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 70 &amp;&amp; score &lt; 80)&#123; // 70-79 C</span><br><span class="line">        printf(&quot;C&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 60 &amp;&amp; score &lt; 70)&#123; // 60-69 D</span><br><span class="line">        printf(&quot;D&quot;);</span><br><span class="line">    &#125;else&#123;  //小于60 E</span><br><span class="line">        printf(&quot;E&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>else if 可以有0个或多个,  else 只能有0个或1个.</p><p>如果我们只需判断学生是否及各, 那么我们就可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (score &gt;= 60)&#123;</span><br><span class="line">    printf(&quot;及格&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    printf(&quot;不及格&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以只有if() 没有else ,  只有if() 和 if else()没有else.</p><h3 id="2-switch-case-语句"><a href="#2-switch-case-语句" class="headerlink" title="2)switch-case 语句"></a>2)switch-case 语句</h3><p>在C语言中, 第二种分支结构就是switch-case, 只是用的地方不太多, 因为if语句可以轻松替代switch语句, 只是结构上没switch那么清晰.</p><p>语法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (变量或表达式)&#123;</span><br><span class="line">    case 常量表达式1: 语句块1; break;</span><br><span class="line">    case 常量表达式2: 语句块2; break;</span><br><span class="line">    ......</span><br><span class="line">    case 常量表达式n: 语句块n; break;</span><br><span class="line">    default: 语句块n+1; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是成绩评级的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int score = 78;  //模拟输入</span><br><span class="line">    </span><br><span class="line">    switch(score / 10)&#123; //case匹配的数据就是score/10的结果  </span><br><span class="line">        case 10: </span><br><span class="line">        case 9: printf(&quot;A&quot;); break;</span><br><span class="line">        case 8: printf(&quot;B&quot;); break;</span><br><span class="line">        case 7: printf(&quot;C&quot;); break;</span><br><span class="line">        case 6: printf(&quot;D&quot;); break;</span><br><span class="line">        default: printf(&quot;E&quot;); break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>score/10 得到的整数就是那个阶段的成绩, 我们会发现case 10: 也就是100分匹配后面没有任何的操作, 最主要的是, 没有break;</p><p>在switch语句中, 如果case匹配到了语句, 那么后面的语句都会执行知道出现第一个break, 或者执行完成.</p><p>如果我们将上面代码中的break全部去掉.score还是78, 那么输出就会变成 CDE, 也就是匹配到7 然后输出7之后的所有语句,知道碰到break;</p><p>default相当于else, 其他所有不匹配的情况, 因为一般是放在最下面, 所以default后面的break可以不写.</p><p><strong>重点</strong>:switch的条件只能是整型和字符型(其实就是字符的ascii码)或者这些类型的表达式,case匹配的只能是整型或者字符型常量或者这两个类型的常量表达式, 也就是case不能匹配变量.</p><h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><p>循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。</p><p>在C语言中有三种循环结构: for循环, while循环, do-while循环.</p><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1) for循环"></a>1) for循环</h3><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(表达式1; 表达式2; 表达式3)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句1：初值表达式，常用于在循环开始前为循环变量赋初值<br>语句2：循环控制逻辑表达式，控制循环执行和结束的条件<br>语句3：循环变量修改表达式，常用于修改循环变量,使得结果趋向于循环结束条件.</p><p>举个栗子:</p><p>循环输出10个”hello world!!!”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i &lt;= 10; i++)&#123; //循环10次, i++为 i自增长1</span><br><span class="line">        printf(&quot;hello world!!!\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉for循环的执行过程:</p><p>1.执行表达式1, i = 1, 只执行一遍.</p><p>2. 执行表达式2, 判断 i &lt;=10</p><p>3.如果表达式2成立, 执行循环体  { printf(“hello world!!!\n”); } 否则执行退出循环, 后续步骤都不执行.</p><p>4.执行完成循环体后,执行表达式3, i++, i的值自动增长1. 回到步骤2去判断.</p><p>for循环中的三个表达式都可以为空, 但是一定要写两个分号也就是 for( ; ; ) 这样就代表无限循环, 也就是死循环.不过一般不会这样用.</p><p>而for循环常用的是对数组的操作,所以初始值一般是0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int Stu\[10\] = &#123;99, 87, 76, 59, 73, 45, 99, 39, 88, 19&#125;; //班级10个学生的成绩</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++)&#123;    //循环10次, 0~9</span><br><span class="line">    printf(&quot;学号为:%d, 成绩为: %d\\n&quot;, i+1, Stu\[i\]);   //数组下标从0开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以发现, 正常的for循环可以很清晰的明白for循环的循环次数.</p><p>所以在你很清晰明白这次循环需要循环多少次的时候推荐使用for循环.</p><h3 id="2-while-循环"><a href="#2-while-循环" class="headerlink" title="2)  while 循环"></a><strong>2)  while 循环</strong></h3><p>while循环的语法简单易懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(表达式)&#123;</span><br><span class="line">       语句块</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行过程: 执行表达式, 如果成立执行语句块, 否则退出循环.</p><p>while循环也可以和for循环互换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//for -&gt; while</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10)&#123;</span><br><span class="line">    //循环体</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">//while -&gt; for</span><br><span class="line">for (;l &lt; r;)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-&gt;while: 没有for循环那么清晰明了的知道循环次数.</p><p>while-&gt;for: 没有while循环那么简单易懂了.  </p><p>所以while循环的一般用法是我们不太清楚循环在什么时候结束, 并且我们也不关心具体的循环次数的时候使用.  </p><p>举个例子: 二分查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line"> </span><br><span class="line">int main()&#123;  </span><br><span class="line">    int a\[10\] = &#123;12, 32, 34, 55, 76, 89, 99, 123, 345, 1234&#125;; //递增的数组 </span><br><span class="line">    int l = 0, r = 9, mid; </span><br><span class="line">    int res = 345;  //查找的目标 </span><br><span class="line">    //二分查找位置 </span><br><span class="line">    while(l &lt;= r)&#123; </span><br><span class="line">        mid = (l+r)/2; </span><br><span class="line">        if (res == a\[mid\])&#123;  //找到了输出位置, 并退出循环. </span><br><span class="line">            printf(&quot;位置: %d\\n&quot;, mid+1); break; </span><br><span class="line">        &#125;else if(res &lt; a\[mid\])&#123;  </span><br><span class="line">            r = mid-1; </span><br><span class="line">        &#125;else&#123;   </span><br><span class="line">            l = mid+1; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只看while循环的内容, while(l&lt;=r)  也就是当l&gt;r时循环退出.  </p><p>和for循环不同的是, 我们并不清楚程序在什么时候会退出, l和r在循环中是在不断变换的.这种情况使用while循环是个不错的选择.</p><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3) do-while循环"></a><strong>3) do-while循环</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;while(表达式);</span><br></pre></td></tr></table></figure><p>和while循环不同的是,do-while循环是先执行一遍循环体,再判断是否满足表达式.</p><p>注意: do-while循环最后是有一个分号结尾的.</p><p>do-while循环的用处也就在先执行一遍循环体再判断, 那么如果我们需要判断的内容必须要执行一遍循环体才能知道的话,那么就可以使用do-while循环.</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int res = 89;</span><br><span class="line">    do&#123;</span><br><span class="line">        printf(&quot;请输入一个数字,输入0退出游戏:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">        if(t == res)&#123;</span><br><span class="line">            printf(&quot;猜对了!\\n&quot;);</span><br><span class="line">        &#125;else if (t &gt; res)&#123;</span><br><span class="line">            printf(&quot;太大\\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;太小\\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;while(t != 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个例子bug很多, 但是我们可以清晰的理解do-while循环的不同, 我们一开始并不清楚t的值, 当我们执行完循环体后才知道t的值,然后做判断.</p><p>三大循环总结:</p><p>for 循环: 在你很清晰明白这次循环需要循环多少次的时候推荐使用.</p><p>while循环: 在我们不太清楚循环在什么时候结束, 并且我们也不关心具体的循环次数的时候推荐使用.  </p><p>do-while循环: 如果我们需要判断的内容必须要执行一遍循环体才能知道的话推荐使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构；&lt;/p&gt;
&lt;p&gt;顺序结构，从头到尾一句接着一句的执行下来，直到
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言03_构造类型  数组, 结构体, 共用体, 枚举类型介绍</title>
    <link href="https://ipanyiwen.github.io/2018/02/05/c-e8-af-ad-e8-a8-8003-e6-9e-84-e9-80-a0-e7-b1-bb-e5-9e-8b-e6-95-b0-e7-bb-84-e7-bb-93-e6-9e-84-e4-bd-93-e5-85-b1-e7-94-a8-e4-bd-93-e6-9e-9a-e4-b8-be-e7-b1-bb-e5-9e-8b-e4-bb-8b-e7-bb-8d/"/>
    <id>https://ipanyiwen.github.io/2018/02/05/c-e8-af-ad-e8-a8-8003-e6-9e-84-e9-80-a0-e7-b1-bb-e5-9e-8b-e6-95-b0-e7-bb-84-e7-bb-93-e6-9e-84-e4-bd-93-e5-85-b1-e7-94-a8-e4-bd-93-e6-9e-9a-e4-b8-be-e7-b1-bb-e5-9e-8b-e4-bb-8b-e7-bb-8d/</id>
    <published>2018-02-04T18:18:06.000Z</published>
    <updated>2018-07-02T06:24:43.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言构造类型"><a href="#C语言构造类型" class="headerlink" title="C语言构造类型:"></a>C语言构造类型:</h1><h2 id="1-C语言中构造类型分为以下四种"><a href="#1-C语言中构造类型分为以下四种" class="headerlink" title="1. C语言中构造类型分为以下四种:"></a>1. C语言中构造类型分为以下四种:</h2><ul><li><strong>数组</strong></li><li><strong>结构体</strong></li><li><strong>共用体</strong></li><li><strong>枚举类型.</strong></li></ul><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1) 数组"></a>1) 数组</h3><p>概念:为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组 知识点: 数组的开始下标都是从0开始的. 我们需要记录一些数据类型相同的数据, 比如记录一个班每个学生的总成绩, 我们可以为每个学生创建一个变量,然后将总成绩赋值,但是这样太麻烦,代码也特别长,  这个时候就需要用到数组来记录. C语言常用的数组: 1. 整型数组:一系列的整数集合.</p><pre><code>//定义一个长度为10的整型数组.int a[10];//定义一个长度为10的整型数组,并初始化.int a[10]  = {100, 98, 99, 60, 79, 45 ,9 ,68 ,79, 80};int a[] = {100, 98, 99, 60, 79, 45 ,9 ,68 ,79, 80};</code></pre><p>根据上面的例子可以发现: <strong>数组定义的方式: 和定义普通的数据类型很相似, 但是数组后加上了一个[]并在里面写明了数组的长度.</strong> <strong>数组的初始化: 初始化数据在一对花括号中,并用逗号隔开,但是如果我们不想计算有多少个元素,可以省略中括号中数组的长度,编译器会根据我们后面花括号中的内容自动计算数组的长度.</strong> <strong>如果只是定义数组而不写后面的初始化,一定要记得不能省略中括号中的数组长度.</strong> <strong>数组的访问:   通过中括号加上下标来访问的.</strong></p><pre><code>printf(&quot;%d\n&quot;, a[0]);  //输出第0个元素a[3] = 99;  //将第4个元素 改为99.</code></pre><p>  2. 浮点数数组: 一系列的浮点数的集合.</p><pre><code>//定义一个长度为10的浮点数数组.double a[10];//定义一个长度为10的浮点数数组并初始化.double a[10] = {100, 98.62, 99.13, 60.5, 79.3, 45.1 ,9.2123, 68.23 ,79.1, 80.9};double a[] = {100, 98.62, 99.13, 60.5, 79.3, 45.1 ,9.2123, 68.23 ,79.1, 80.9};double a[10] = {1.2, 3.5};</code></pre><p>根据上面的写法我们发现, 如果我们定义了一个长度为10的数组,但是我们不在花括号中写满十个数字,那么编译器会将我们写的赋值给数组的前面几个,而后面的数组元素全部赋0,</p><pre><code>//相当于double a[10] = {1.2, 3.5, 0, 0, 0, 0, 0, 0, 0,  0 };</code></pre><p>那么我们可以断定 int a[10] = {}; 那么a[10]中全部都是0, 那么如果只是定义一些 int a[10]; 呢?我们可以来测试一下.</p><pre><code>#include &lt;stdio.h&gt;int main(){    int i, a[10]={}, b[10];    printf(&quot;int a[10] = {};的输出: &quot;);    for (i = 0; i &lt; 10; i++){        printf(&quot;%d &quot;, a[i]);    }    printf(&quot;\n&quot;);    printf(&quot;int b[10];的输出: &quot;);    for (i = 0; i &lt; 10; i++){        printf(&quot;%d &quot;, b[i]);    }    printf(&quot;\n&quot;);    return 0;}</code></pre><p>我们看看输出: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/未命名.jpg" alt=""> 我们会发现,如果是直接定义int a[10]; 的其实是系统随机的值. 知道了这个我们通常会发现一些C语言的数组代码这样写:</p><pre><code>int a[100] = {0};</code></pre><p>这个其实就是初始化一个a[100]的数组,并将里面的值全部赋值为0.在花括号中写个0是使得代码更加易懂. 3.字符数组: 定义一个字符型数组.</p><pre><code>//定义一个长度为5的字符数组char s[5];//定义一个长度为5的字符数组, 并初始化.char s[5] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;}char s[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;}char s[5] = &quot;abcd&quot;;char s[] = &quot;abcd&quot;;</code></pre><p>这个时候会发现为什么长度为5的字符数组用双引号里面只放四个字母,而单引号放五个. 字符串: 相当于一串字符,用来表示一些语句子类的,其实也就是另类的字符数组.</p><pre><code>char c[] =  &quot;I Love C!&quot;; //字符串char c1[] = {&apos;I&apos;, &apos; &apos;, &apos;L&apos;, &apos;o&apos;, &apos;v&apos;, &apos;e&apos;, &apos; &apos;, &apos;C&apos;, &apos;!&apos;}; //字符数组</code></pre><p>这样应该比较清楚为什么会有字符串了. 便于理解! 虽然这两个都表示同样的一句话, 但是其实是有差别的, 第一个长度是10, 第二个长度是9. 原因就在于字符串的结尾有个\0的结束符号,代表这个字符串结束了.那么为什么要这样做呢? 我们举个例子:</p><pre><code>#include &lt;stdio.h&gt;int main(){    char s[20]; //字符数组    char s1[20] = &quot;I Love C!&quot;; //字符串    //模拟我们一个一个输入:    s[0] = &apos;I&apos;;    s[1] = &apos; &apos;;    s[2] = &apos;L&apos;;    s[3] = &apos;o&apos;;    s[4] = &apos;v&apos;;    s[5] = &apos;e&apos;;    s[6] = &apos; &apos;;    s[7] = &apos;C&apos;;    s[8] = &apos;!&apos;;    printf(&quot;字符数组: %s\n&quot;, s); //%s字符串标准输出    printf(&quot;字符串: %s\n&quot;, s1);    return 0;}</code></pre><p>看看输出结果: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/未命名-1.jpg" alt="">     有没有发现,字符数组后面多了一个很奇怪的符号? 这个并不是意外,还记得我们上面说的,如果只是定义数组,系统会自动随机给数字给数组,如果没有’\0’作为结束符号,那么系统就会一直输出到出现’\0’为止.字符串输出的后面就会出现一些奇怪的符号,在windows中最常见的就是一堆”烫烫烫”. ‘\0’就是ascii码中的0.可以修改上述代码,char s[20]={0}然后试试.绝对不会出现刚刚那样的错误. <strong>多维数组:</strong> 之前我们使用的都是一维数组, C语言提供了多维数组的使用,虽然用的情况可能不多, 但是还是需要了解一些. 假设还是一个班的学生, 我们在教室, 教室有10排, 12列, 在玩一个游戏, 要记录分, 我们可以这样记录, 第三排第五列的学生成绩为89分. 第10排第11列的学生成绩为100分. 那么我们可以使用二维数组这样定义:</p><pre><code>int Stu[10][12] = {0};  //定义一个10排12列的教室, 将所有学生的初始成绩为0Stu[2][4] = 89; //第三排第五列的学生成绩为89.数组都是以0开始的.Stu[9][10] = 100; //第10排第11列的学生成绩为100. //但是这样会不会很不方便去理解 , 其实只要用多了你眼中这些就不会太难理解.//也可以换个好理解的方式来定义, 但是这样浪费内存.不建议使用.int Stu[11][13] = {0}; //定义教室, 我们不用第0排, 第0列.Stu[3][5] = 89; //第三排第五列的学生成绩为89.数组都是以0开始的.Stu[10][11] = 100; //第10排第11列的学生成绩为100. </code></pre><p>二维数组就是这样,那么三维也是同理.使用的情况即更少了.</p><h3 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2) 结构体"></a>2) 结构体</h3><p><strong>结构体: 把不同类型的数据组合成一个整体</strong> 我们想要记录一个班所有学生的成绩,为了不定义所有学生的变量,我们使用数组,但是我们当然希望记录学生的姓名,各个科目的成绩.</p><pre><code>struct Student{    int id; //学号    char name[20]; //姓名    float Math; //数学成绩    float Chinese; //语文成绩    float Engish; //英语成绩};</code></pre><p>结构体的一般用法:</p><pre><code>struct Student A;  //定义一个学生A   //模拟输入   A.id = 1;   A.name[0] = &apos;T&apos;;    //如果是输入, 可以直接输入字符串.   A.name[1] = &apos;o&apos;;   A.name[2] = &apos;m&apos;;   A.name[3] = &apos;\0&apos;;   A.Math = 99.9;   A.Chinese = 100;   A.Engish = 100;</code></pre><p>在C语言我们可以选择用结构体去存储这样一个学生的信息.但是我们要存储多个学生呢? 应该知道的, 结构体数组. 定义方法:</p><pre><code>struct Student Stu[50];  //定义50个学生的数组//还有一种是直接在结构体定义时候初始化.  就像int a = 10;struct Student{    int id; //学号    char name[20]; //姓名    float Math; //数学成绩    float Chinese; //语文成绩    float Engish; //英语成绩}Stu[50]; //初始化50个学生的数组</code></pre><p>对于结构体数组的用法和普通用法数组用法也一样.</p><pre><code>Stu[0].id = 1001;   //将0号学生的学号改为1001printf(&quot;%s\n&quot;, Stu[10].name);  //输出10号学生的姓名</code></pre><h3 id="3-共用体"><a href="#3-共用体" class="headerlink" title="3) 共用体"></a>3) 共用体</h3><p><strong>几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构</strong> 共用体在写法上和结构体很相似.</p><pre><code>union data{    int i;    char ch;    double d;};</code></pre><p>但是共用体相当于这三个变量共用一段地址, 我们创建变量 union data a; 那么这个a占用多少字节呢? 就是union data中字节最多 double d, 所以这个union占用了8个字节. int 为四个字节, 如果我们访问 a.i, 就会去内存中取前(或者后, 不同编译器)4个字节, 同理访问a.ch 就会去内存中去前1个字节, 如果访问a.d就会8个字节全部取出. 举个栗子:</p><pre><code>#include &lt;stdio.h&gt;union data{    int i;    char ch;    short s;};int main(){    union data a;    a.i = 97;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    //因为int 占4个字节 范围 -2147483648 ~ 2147483647    //char 占1个字节 范围 -128 ~ 127    //short 占2个字节 范围 -32768 ~ 32767    a.i = 128;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    a.i = 32768;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    return 0;}//输出结果:a.i = 97, a.ch = a, a.s=97a.i = 128, a.ch = �, a.s=128a.i = 32768, a.ch = , a.s=-32768</code></pre><h3 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4) 枚举类型"></a>4) 枚举类型</h3><p><strong>如果一个变量只有几种可能的值，则可以定义为“枚举类型”.</strong> 比如限定几种颜色, 星期一到星期天. 都可以使用枚举类型来表示. 定义</p><pre><code>enum Color{red,yellow,blue,green};</code></pre><p>用法:</p><pre><code>#include &lt;stdio.h&gt;enum Color{red,yellow,blue,green};int main(){    enum Color c;    c = red;    if (c == red){        printf(&quot;红色\n&quot;);    }    return 0;}</code></pre><p>输出就是红色. 枚举类型可以让我们更加直观的感受到这个颜色就是一种类型. 但其实每个颜色都代表着一个数字,所以我们用==判断就是比较数字.我们可以将if(c== red) 改为if(c == 0) 结果也是一样的. 当然枚举类型还能自己给每个枚举元素赋一个代表它的整数.</p><pre><code>#include &lt;stdio.h&gt;enum Color{red=2,yellow,blue,green};int main(){    printf(&quot;%d %d %d %d\n&quot;, red, yellow , blue, green);    return 0;}</code></pre><p>输出结果:</p><pre><code>2 3 4 5</code></pre><p>如果我们再改动blue = 7, 结果</p><pre><code>2 3 7 8</code></pre><p>更加可怕的是, 我们可以将enum的多个元素设置为一个值:</p><pre><code>#include &lt;stdio.h&gt;enum Color{red=2,RED=2, yellow,blue,green}; int main(){    enum Color c = red;    if(c == RED){        printf(&quot;红色!\n&quot;);    }    return 0; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言构造类型&quot;&gt;&lt;a href=&quot;#C语言构造类型&quot; class=&quot;headerlink&quot; title=&quot;C语言构造类型:&quot;&gt;&lt;/a&gt;C语言构造类型:&lt;/h1&gt;&lt;h2 id=&quot;1-C语言中构造类型分为以下四种&quot;&gt;&lt;a href=&quot;#1-C语言中构造类型分为以下四
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言02_基本数据类型</title>
    <link href="https://ipanyiwen.github.io/2018/02/04/c-e8-af-ad-e8-a8-8002-e5-9f-ba-e6-9c-ac-e6-95-b0-e6-8d-ae-e7-b1-bb-e5-9e-8b/"/>
    <id>https://ipanyiwen.github.io/2018/02/04/c-e8-af-ad-e8-a8-8002-e5-9f-ba-e6-9c-ac-e6-95-b0-e6-8d-ae-e7-b1-bb-e5-9e-8b/</id>
    <published>2018-02-04T04:14:25.000Z</published>
    <updated>2018-07-02T06:24:24.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言的数据类型"><a href="#C语言的数据类型" class="headerlink" title=" C语言的数据类型:"></a> C语言的数据类型:</h1><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/Cshujuleixing.png" alt=""></p><h2 id="知识点-C语言中-unsigned-和-signed-关键字-用来修饰变量是否带符号-也就是正负-unsigned-无符号-lt-gt-变量只能是大于等于0的数-signed-有符号-lt-gt-变量可以是负数"><a href="#知识点-C语言中-unsigned-和-signed-关键字-用来修饰变量是否带符号-也就是正负-unsigned-无符号-lt-gt-变量只能是大于等于0的数-signed-有符号-lt-gt-变量可以是负数" class="headerlink" title="知识点: C语言中, unsigned 和 signed 关键字,用来修饰变量是否带符号,也就是正负. unsigned 无符号&lt;=&gt; 变量只能是大于等于0的数,  signed 有符号 &lt;=&gt; 变量可以是负数."></a>知识点: C语言中, unsigned 和 signed 关键字,用来修饰变量是否带符号,也就是正负. unsigned 无符号&lt;=&gt; 变量只能是大于等于0的数,  signed 有符号 &lt;=&gt; 变量可以是负数.</h2><p><strong>编译器的基本数据类型变量如果不声明一般默认是有符号的.</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h2><h3 id="1-整型-整型变量表示的是整数类型的数据-默认有符号"><a href="#1-整型-整型变量表示的是整数类型的数据-默认有符号" class="headerlink" title="1.整型: 整型变量表示的是整数类型的数据. 默认有符号."></a>1.整型: 整型变量表示的是整数类型的数据. 默认有符号.</h3><p>整数分为 正整数, 负整数, 0. 所以计算机为了表示正负,用了第一位当符号位.</p><ul><li>int  基本型, 在32位和64位系统上都占4个字节. 占用内存也就是32位,因为是二进制表示,所以2^32=4294967296,  去掉一位符号为, 0占一位, 所以范围表示: -2^31 ~ (2^31) - 1&lt;=&gt; -2147483648 ~ 2147483647.</li><li>short 短整型, 在32位和64位系统上都占2个字节. 占用内存16位&lt;=&gt;范围:-2^15 ~ (2^15) -1 &lt;=&gt; -32768~32767</li><li>long 长整型, 在32位系统上是4字节,64位系统是8字节.内存如上计算.</li><li>__int64 | long long  在VC中是__int64,在gcc中是long long, 用来表示超过了32位的整数.占用内存64位.</li></ul><h3 id="2-浮点型-浮点型变量表示的是实数类型的数据-有符号而且不能用unsigned修饰-实数类型没有无符号类型"><a href="#2-浮点型-浮点型变量表示的是实数类型的数据-有符号而且不能用unsigned修饰-实数类型没有无符号类型" class="headerlink" title="2.浮点型: 浮点型变量表示的是实数类型的数据.有符号而且不能用unsigned修饰.实数类型没有无符号类型."></a>2.浮点型: 浮点型变量表示的是实数类型的数据.有符号而且不能用unsigned修饰.实数类型没有无符号类型.</h3><ul><li>float 单精度浮点数 占4个字节, 占用内存是32位.</li><li>double 双精度浮点数 占8个字节, 占用内存64位.</li></ul><p>浮点数在计算机内用指数型式表示, 可以分解为：数符, 尾数, 指数符, 指数四部分。 数符占1位, 表示数字的正负. 指数符占1位, 表示指数的正负. 尾数表示浮点数有效数字, 即小数点后多少位. 指数存指数的有效数字. 指数占多少位, 尾数占多少位, 由计算机系统决定. 如果是数符加尾数占24位, 指数符加指数占8位 即 float. 数符加尾数占48位, 指数符加指数占16位 即 double.</p><h3 id="3-字符类型-字符变量表示的是单个字符类型的数据-默认符号是根据编译器来的"><a href="#3-字符类型-字符变量表示的是单个字符类型的数据-默认符号是根据编译器来的" class="headerlink" title="3.字符类型: 字符变量表示的是单个字符类型的数据. 默认符号是根据编译器来的."></a>3.字符类型: 字符变量表示的是单个字符类型的数据. 默认符号是根据编译器来的.</h3><ul><li>char 字符型 占1个字节, 占用内存8位.</li></ul><p>我们键盘上的26个字母加上大小写, 加特殊字符等按照从0~127编号, 这就是该字符的ascii码.所以char类型本质其实就是一位的整数.         注意: 在c语言中一个汉字是占2个字符的.所以需要字符数组来表示.这个很好理解,因为中文2^8=256个全部用来表示中文也不够.所以用两个字符表示, 2^16=65536个字符,就能表示几乎全部的中文了.但是其他的一些语言中文是用一个字符来表示,但是这些语言一个字符一般都是两个字节.<br>想要详细了解下编码方式可以参考:  <a href="http://www.welcom212.com/wordpress/?p=20" target="_blank" rel="noopener">编码方式</a> </p><p><strong>    unsigned char 和 signed char: </strong> 我们一般的编译器像 VC, GCC的默认char类型是有符号的,据说 arm-linux-gcc上的char类型是无符号的, 也就是unsigned char类型, 因为ascii码只有127个, 所以无符号和有符号的用法差别不大.</p><p>其他语言可能还有byte(字节)类型, 在c语言中可以用unsigned char 来模拟.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//写法</span><br><span class="line">int a = 1;</span><br><span class="line">double b = 1.123;</span><br><span class="line">char c = &apos;A&apos;;</span><br><span class="line">unsigned char c = 200;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言的数据类型&quot;&gt;&lt;a href=&quot;#C语言的数据类型&quot; class=&quot;headerlink&quot; title=&quot; C语言的数据类型:&quot;&gt;&lt;/a&gt; C语言的数据类型:&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://120.78.85.68/wordpress/wp
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言01_介绍+helloworld</title>
    <link href="https://ipanyiwen.github.io/2018/02/03/c-e8-af-ad-e8-a8-8001-e4-bb-8b-e7-bb-8dhelloworld/"/>
    <id>https://ipanyiwen.github.io/2018/02/03/c-e8-af-ad-e8-a8-8001-e4-bb-8b-e7-bb-8dhelloworld/</id>
    <published>2018-02-02T17:24:39.000Z</published>
    <updated>2018-07-02T03:51:23.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h2><p>C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。  </p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器:"></a>编辑器:</h2><p>CodeBlocks ,功能比较齐全,下载的时候务必看清是否带有编译器,一般是默认自带了MinGW. 附个:  <a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="noopener">下载链接</a> windows的话, 选择文件后缀为 mingw-setup.exe的下载.</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><p>一个入门的C语言程序hello world,向计算机的世界发出我们的问候.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world!!!\\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果就是在终端输出一个字符串: hello world.</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释:"></a>代码解释:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><p>C语言引入库函数的方式, 因为后面用了标准输出函数printf.而这个方法是写在stdio.h这个标准输入输出库文件中的函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;&#125;</span><br></pre></td></tr></table></figure><p>C语言程序的入口点,main函数, 返回值为int ,  后面有个return 0.  这个就是返回值, 返回一个0代表正常结束.花 括号代码块, 函数后接上一对花括号,花括号里面的内容都为函数体.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;hello world!!!\\n&quot;);</span><br></pre></td></tr></table></figure><p>标准输出函数,向终端显示一条字符串”hello world!!!”.   ‘\n’为换行,如果”123\n456”. 那么456就会显示在下一行中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>返回值,因为main函数前定义了返回值为int , 所以必须返回一个整形数字,而0一般代表正常结束,当然返回其他整数也不会报错,但是不建议这样做.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介:&quot;&gt;&lt;/a&gt;简介:&lt;/h2&gt;&lt;p&gt;C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>笔记：jsp的九大内置对象和四大作用域</title>
    <link href="https://ipanyiwen.github.io/2018/01/29/e7-ac-94-e8-ae-b0-ef-bc-9ajsp-e7-9a-84-e4-b9-9d-e5-a4-a7-e5-86-85-e7-bd-ae-e5-af-b9-e8-b1-a1-e5-92-8c-e5-9b-9b-e5-a4-a7-e4-bd-9c-e7-94-a8-e5-9f-9f/"/>
    <id>https://ipanyiwen.github.io/2018/01/29/e7-ac-94-e8-ae-b0-ef-bc-9ajsp-e7-9a-84-e4-b9-9d-e5-a4-a7-e5-86-85-e7-bd-ae-e5-af-b9-e8-b1-a1-e5-92-8c-e5-9b-9b-e5-a4-a7-e4-bd-9c-e7-94-a8-e5-9f-9f/</id>
    <published>2018-01-29T14:15:12.000Z</published>
    <updated>2018-07-02T06:27:26.997Z</updated>
    
    <content type="html"><![CDATA[<p>知识点: 一个jsp页面的本质其实就是一个servlet。重写了Service方法。 tomcat服务器将jsp自动生成servlet的代码存放位置就在tomcat安装目录下的work中。 我的是在：C:\Program Files\Apache Software Foundation\Tomcat 9.0\work\Catalina\localhost\myPro\org\apache\jsp 创建一个 test.jsp页面 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171332.png" alt=""> </p><p>服务器自动生成的servlet代码:</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171216.png" alt=""> </p><p>jsp由Java代码和HTML代码组成，在生成的servlet中HTML代码是由 javax.servlet.jsp.JspWriter的对象out.write(“<html>…</html>“)写的。这个对象JspWriter正好是jsp的九大内置对象之一的out。</p><h1 id="九大内置对象："><a href="#九大内置对象：" class="headerlink" title="九大内置对象："></a><strong>九大内置对象：</strong></h1><p>内置对象： jsp也就是servlet自动创建了九个对象。 page、config、request、response、session、application、out、exception、pageContext exception对象默认不会创建，request和response对象作为参数传入。所以将test.jsp 生成的servlet打开可以看到剩下的6个内置对象的定义。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171945.png" alt=""></p><h2 id="1-page对象"><a href="#1-page对象" class="headerlink" title="1.page对象"></a><strong>1.page对象</strong></h2><p>根据定义我们可以发现page对象的创建：final java.lang.Object page = this; 也就是page的本身就是servlet类本身（this）。</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128173036.png" alt=""> </p><p>我们可以在jsp打印this和page的地址会发现是指向同一个地址，但是一些方法却被隐藏起来了。 page变量属于pageContext域， 也就是作用范围是当前jsp页面。这很容易理解了。当前page就是当前这个servlet的this指针。当然不能到其他页面。当然刷新页面相当于重新访问servlet，所以page也就重新刷新。之前储存的内容当然也就清空了。</p><h2 id="2-config对象"><a href="#2-config对象" class="headerlink" title="2.config对象"></a><strong>2.config对象</strong></h2><p>web容器在初始化时使用一个ServletConfig(即config)对象向JSP页面传递信息，此配置信息包括初始化参数（在当前Web应用的应用部署描述文件web.xml中定义）以及表示Servlet或JSP页面所属Web应用的ServletContext对象。 也就是说config对象可以将web.xml配置信息传递到jsp页面。但是jsp初始化配置信息情况比较少，但是对于servlet的使用的情况较多。用法: web.xml配置：</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128220550-e1517151181611.png" alt=""> </p><p>servlet写法：</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128220515.png" alt=""> </p><p>我们可以在web.xml配置数据库的账号密码。然后再servlet中得到这个账号密码。当然还能得到一些其他的配置信息。 所以conf对象当然属于pageContext域，作用范围也固然是当前页面。</p><h2 id="3-request对象"><a href="#3-request对象" class="headerlink" title="3. request对象"></a>3. request对象</h2><p>根据servlet中会发现，request对象并没有在servlet中定义，request对象是作为参数传递过来的。其实request对象是在客户端(浏览器)发送一次请求，服务器(tomcat)自动帮我们将请求的消息封装进request中，生成request对象传给servlet。所以request对象包含了客户端发起请求的所有信息。 request对象的作用是与客户端交互，收集客户端的Form、Cookies、超链接，或者收集服务器端的环境变量。 <strong>request对象的常用方法:</strong></p><ul><li>String getParameter(String name),获取客户端的参数值，常用于表单</li><li>String[] getParameterValues(String name),获取单个参数的所有值，常用语表单中的多选</li><li>Enumeration getPameterName(),获取所有的参数的名称</li><li>void setCharacterEncoding(String encoding),设置字符编码方式</li><li>Cookie[ ] getCookies(),得到所有的Cookies</li></ul><p>当然request还可以得到和设置请求头所有信息。 request还有一个很重要的作用：请求转发。</p><ul><li>request.getRequestDispatcher(“url”).forward(request, response);</li><li>request.getRequestDispatcher(“url”).include(request, response);</li></ul><p>因为可以转发，request对象可以存放数据， 用法：request.setAttribute(str, Object); 在转发的jsp页面中取数据：Object = request.getAttribute(str);   forward 和 include 的实质： 我们在servlet中分别用forward和include请求转发跳转页面。用out输出一些内容到网页中，并打印request对象和response对象的地址。然后在跳转的页面输出request对象和response对象的地址。</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129152359.png" alt=""> </p><p>不论是forward还是include会发现地址不同，也就是jsp页面中的request，forward和servlet中的不是同一个request。但是却可以得到信息，所以应当是拷贝了一份request过去。 forward转发会发现，不论是转发前的“hhhh”还是转发后的“h1111hhh”，都不会在test.jsp的页面中输出。而include却会输出。 我们查看两者的jsp页面的源码便可发现，其实include其实是将servlet所代表的jsp页面和转发的jsp页面合并。所以如果前一个只是单纯的servlet页面，并无jsp。那么include就可以输出一些东西到转发的jsp页面中，但是include并不常用。 也就是response并不会传递，只是两个页面合并后才能用转发前页面的response对象的getWriter。 因此：请求转发只能转发到同一web项目的资源。客户浏览器只做了一次请求，服务器完成请求处理并转发请求，页面跳转。所以url地址不会变化，仍然是客户端（浏览器）的第一次请求的URL。 请求转发，不改变url地址，会跳转界面，还会将request对象的信息传递过去，直到请求结束，才会销毁request对象。 所以request对象属于request域，在请求结束后才会真正销毁。虽然每个页面都会新建一个request对象，但是对于请求转发来说，request会完全复制过去，也就相当于request对象并未消失。所以属于request域。刷新页面相当于重新发送请求，所以request对象会重新创建，之前的信息丢失。</p><h2 id="4-response对象"><a href="#4-response对象" class="headerlink" title="4. response对象"></a><strong>4. response对象</strong></h2><p>Response对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response对象只提供了一个数据集合cookie，它用于在客户端写入cookie值。若指定的cookie不存在，则创建它。若存在，则将自动进行更新。结果返回给客户端浏览器。 response最重要的就是响应页面。所以response最重要的也就是得到和设置响应头的信息 常用方法：</p><blockquote><ul><li>String setCharacterEncoding()//设置响应字符编码格式</li><li>String getCharacterEncoding()//获取响应字符编码格式</li><li>void setContentType(String type)//设置响应MIME类型</li><li>sendRedirect(java.lang.String location)//请求重定向</li><li>PrintWriter getWriter()//获取打印输出对象</li></ul></blockquote><p>response可以响应界面并给浏览器添加cookie 用法：response.addCookie(cookie); response还有一个很重要的功能，重定向： 用法：response.sendRedirect(location); 重定向也可以跳转界面，但是与请求转发不同的是重定向并不能传递request,地址栏上的url也会发生变化，而且能够访问其他web项目的资源。 本质：客户端(浏览器)发送了两次请求。客户端(浏览器)发送第一次请求，服务器接受处理，response返回一个状态码302  (3xx状态码重定向到其他地方: 需要客户端再次发送请求),客户端(浏览器)接收，发现是302，于是又发送了一条请求，请求的url便是重定向的参数location，服务器接收请求处理并跳转页面。 因为是客户端（浏览器）发送的请求，所以自然可以访问其他web项目。地址栏也自然会发生变化。 因此，response其实是pageContext域的属性，在访问jsp或者servlet时服务器自动创建，但是在有关请求转发或者重定向时，都没有拷贝过去，所以response是自然是属于pageContext域。</p><h2 id="5-session对象"><a href="#5-session对象" class="headerlink" title="5. session对象"></a><strong>5. session对象</strong></h2><p>Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。 session实现的两种机制： 1. cookie, 服务器没生成一个session对象存储信息，每个session对象都有一个sessionid， 响应客户端（浏览器）生成一个cookie，存放sessionid，服务器会读取cookie中的sessionid来检索到以前的session对象。 2.重写url，上述方法在浏览器禁用cookie的话无法实现，所以我们在每个访问的url后加上sessionid也同样能做到。 得到session的一种方式： HttpSession session = request.getSession(); 为session设值： session.setAttribute(“usrid”, userid); 取值： userid = session.getAttribute(“usrid”); session的生存周期，session会在客户端关闭，或者超过设定时间时自动销毁，默认为30分钟。 设值时间的一种方式，也可以在xml配置文件，或者tomcat中配置。 session.setMaxInactiveInterval(900);  //在60*15 = 900， 15分钟后销毁 故，session属于session域。生存周期为时间到，或者浏览器关闭，自动销毁。</p><h2 id="6-application对象"><a href="#6-application对象" class="headerlink" title="6.application对象"></a><strong>6.application对象</strong></h2><p>application对象的使用方法和session很类似，但是不同的是application的生存周期是在web项目删除或者服务器关闭才会销毁。 原理： 在服务器端创建的对象，储存在服务器端的内容中。所以客户端的一切行为都不会影响到application对象。 所以application属于application域，作用范围在整个web项目。</p><h2 id="7-out对象"><a href="#7-out对象" class="headerlink" title="7. out对象"></a><strong>7. out对象</strong></h2><p>作用向页面输出内容， out对象被封装为javax.servlet.jsp.jspWriter接口，通过调用pageContext.getOut()方法可以获取out对象。 out对象是字符流对象，其作用和用法与ServletResponse.getWriter()方法返回的PrintWriter对象十分类似。都可以向页面输出信息，但是有所不同，那就是PrintWriter输出的内容一般都会在out对象输出内容的前面，给个例子: </p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129200636.png" alt=""> </p><p>访问该页面，得到结果： </p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129200734-300x183.png" alt=""> </p><p>但是也可以按照我们希望的顺序输出，那就是在out输出完后加一个方法 out.flush();顺序就是我们的代码顺序了。 原理： PrintWriter 有一个缓冲区， 当我们用printwriter对象输出页面的内容会全部到缓冲区中，然后输出到页面。而JSPWriter也有这么一个缓冲区，当缓冲区满了就会输出到PrintWriter的缓冲区。然后再一起输出到页面。 刚刚的代码也就是。</p><ol><li>printwriter.write(“&lt;h1&gt;PrintWriter1&lt;/h1&gt;”);   “PrintWriter1”进入PrintWriter的缓冲区。</li><li>out.write(“&lt;h1&gt;JSPWriter&lt;/h1&gt;”);  “JSPWriter”进入JSPWriter的缓冲区。</li><li>printwriter.write(“&lt;h1&gt;PrintWriter2&lt;/h1&gt;”);   “PrintWriter2”进入PrintWriter的缓冲区。</li><li>结束，JSPWriter缓冲区的内容写到PrintWriter的缓冲区中。</li><li>所以PrintWriter的缓冲区变成”PrintWriter1” “PrintWriter2” “JSPWriter”;</li></ol><p>可以用out.getBufferSize()查看缓冲区的大小，我的默认是8192。 out.flush 函数就是讲out缓冲区的内容直接输出到PrintWriter缓冲区中。 一些函数： 1.public abstract void clear() 清除缓冲区中的内容，不将数据发送至客户端。 2.public abstract void clearBuffer() 将数据发送至客户端后，清除缓冲区中的内容。 3.public abstarct void close() 关闭输出流。 4.public abstract void flush() 输出缓冲区中的数据。 5.public int getBufferSize() 获取缓冲区的大小。缓冲区的大小可用&lt;%@ page buffer=”size” %&gt;设置。 6.public abstract int getRemainning() 获取缓冲区剩余空间的大小 7.public boolean isAutoFlush() 获取用&lt;%@ page is AutoFlush=”true/false”%&gt;设置的AutoFlush值。 8.public abstract void newLine() 输出一个换行字符，换一行。 9.public abstract void print() 显示各种数据类型的内容。 10.public abstract void println() 分行显示各种数据类型的内容。 <img src="http://slist.cnblogs.com/aggbug/242334.html" alt=""> 所以out对象为pageContext域。</p><h2 id="8-exception对象"><a href="#8-exception对象" class="headerlink" title="8. exception对象"></a><strong>8. exception对象</strong></h2><p>使用它，必须结合page指令中的isErrorPage属性和errorPage属性。都是在头部定义。如果定义了errorPage=”error.jsp”那么就会抛出异常跳转到error.jsp页面，而不会直接弹出500错误。如果定义了isErrorPage=”true”，就说明这个页面就是能够接受异常的错误界面。 _jspx_page_context对异常的处理也非常简单：如果该页面的page指令指定了errorPage属性，则将请求forward到errorPage属性指定的页面，否则使用系统页面来输出异常信息。但是该页没有内置exception对象。 errorPage页面则定义了exception对象，定义如下：</p><p>java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);</p><p>也就是forward中的request请求带来了exception的信息。所以exception对象只存在error.jsp页面中，不会到其他页面。所以exception作用域：pageContext 举个栗子： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205300.png" alt=""> <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205250.png" alt=""> 运行结果： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205344.png" alt=""></p><h2 id="9-pageContext对象"><a href="#9-pageContext对象" class="headerlink" title="9. pageContext对象"></a><strong>9. pageContext对象</strong></h2><p>JSP页面的管理者(上下文)，它能获得其他八个内置对象。得到四个作用域常量。 1、获得其它八大内置对象 getXxx()c</p><ul><li>pageContext.getOut();　　//获得out对象</li><li>pageContext.getApplication();　　//获得application对象</li><li>pageContext.getRequest();       //获得request对象。</li><li>……  //获得其他内置对象</li></ul><p>2、 提供作用域常量 scope, 其实就是int类型，分别为1、2、3、4。封装起来代表四种类型。</p><ul><li>PageContext.PAGE_SCOPE　　page</li><li>PageContext.REQUEST_SCOPE　　request</li><li>PageContext.SESSION_SCOPE　　response</li><li>PageContext.APPLICATION_SCOPE　　application</li></ul><p>3、为各个域存值和取值</p><ul><li>　pageContext.getAttribute(name [, scope]);　　//获得scope作用域数据</li><li>pageContext.setAttribute(name,value [, scope]);　//给scope作用域设置内容</li><li>　pageContext.removeAttribute(name [, scope]);　　//给scope作用域移除内容</li></ul><p>scope就是上面的四种作用域常量 。 一次获得指定名称内容 4、findAttribute(name);　//依次从page、request、session、application 获得内容。 所以pageContext对象也是pageContext域。它只在本身页面范围有效。</p><h1 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域:"></a><strong>四大作用域:</strong></h1><p>pageContext  &lt;  request  &lt;  session &lt; application, pageContext 域:   范围页面本身。 request 域：   范围一次请求。 session域:  范围在设定时间内整个浏览器，只要浏览器不关闭，都有效。 application域:  范围整个服务器运行。只要项目没被移除，或者服务器没重启或关闭，那么application都存在。</p><p>参考链接，致谢：</p><p><a href="https://www.cnblogs.com/whgk/p/6427759.html" target="_blank" rel="noopener">https://www.cnblogs.com/whgk/p/6427759.html</a> </p><p><a href="http://blog.csdn.net/meiyalei/article/details/2129120" target="_blank" rel="noopener">http://blog.csdn.net/meiyalei/article/details/2129120</a> </p><p><a href="https://www.cnblogs.com/fjdingsd/p/4918748.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjdingsd/p/4918748.html</a></p><p><a href="http://blog.csdn.net/qq_34342083/article/details/53944941" target="_blank" rel="noopener">http://blog.csdn.net/qq_34342083/article/details/53944941</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点: 一个jsp页面的本质其实就是一个servlet。重写了Service方法。 tomcat服务器将jsp自动生成servlet的代码存放位置就在tomcat安装目录下的work中。 我的是在：C:\Program Files\Apache Software Foun
      
    
    </summary>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jsp" scheme="https://ipanyiwen.github.io/tags/jsp/"/>
    
      <category term="九大内置对象" scheme="https://ipanyiwen.github.io/tags/%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议-简单理解和介绍</title>
    <link href="https://ipanyiwen.github.io/2018/01/27/e4-ba-92-e8-81-94-e7-bd-91-e5-8d-8f-e8-ae-ae-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3-e5-92-8c-e4-bb-8b-e7-bb-8d/"/>
    <id>https://ipanyiwen.github.io/2018/01/27/e4-ba-92-e8-81-94-e7-bd-91-e5-8d-8f-e8-ae-ae-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3-e5-92-8c-e4-bb-8b-e7-bb-8d/</id>
    <published>2018-01-27T08:45:37.000Z</published>
    <updated>2018-07-02T06:26:45.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。"><a href="#概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。" class="headerlink" title="概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。"></a><strong>概念</strong>：互联网实现过程中大家都需要遵循的准则，我们称之为协议。</h1><p>前提概要： 我们知道当我们访问互联网是，是在浏览器的导航栏输入一个网址，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> 而一个网址对应的是一个ip地址，所以我们访问网址，那么就很清楚的认识到访问网址，就是访问另外一个ip地址的计算机上储存的网页。那么我们已知的只有计算机的ip，我们就根据这个来了解一下互联网的世界是如何做到的查找到另外的计算机的。</p><h1 id="一、-五层模型。"><a href="#一、-五层模型。" class="headerlink" title="一、 五层模型。"></a><strong>一、 五层模型。</strong></h1><p>互联网的模型有7层模型， 4层模型的说法，5层模型是结合这两种更加利于理解的一种说法。5层模型从上往下分别是：应用层，传输层，网络层，数据链路层，物理层。（名词可能会有点出入，翻译问题） <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/7bf4e8201ee0799d2770a37ed41232eb.png" alt=""></p><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a><strong>1.物理层</strong></h2><p>物理层就是最底层的电路之间的传输，不同的电脑与电脑之间相互通过网线，WiFi等，构建起了整个互联网的基础。</p><h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a><strong>2.数据链路层</strong></h2><p>互联网的电脑数不胜数，我们两台电脑之间怎么相互连接，传递数据呢？首先就需要将电脑相互区分——MAC地址，然后传递数据需要单位吧，不然一堆0101传递过去计算机接受了也无法识别那部分属于什么应用程序的，当时不同得企业选择不同的单位，不同的风格，然后渐渐统一，出现了互联网的一个重要协议 ——以太网协议， 规定数据单位为：帧。</p><h3 id="2-1-MAC地址"><a href="#2-1-MAC地址" class="headerlink" title="2.1 MAC地址"></a><strong>2.1 MAC地址</strong></h3><p>链接网络需要网卡，每台计算机的网卡地址就是MAC地址，每块网卡出厂的MAC地址独一无二。这样每台计算机就有了个独一无二的身份了。</p><h3 id="2-2-以太网协议"><a href="#2-2-以太网协议" class="headerlink" title="2.2 以太网协议"></a><strong>2.2 以太网协议</strong></h3><p>以太网协议规定了网络数据传输过去的单位是一帧， 两台计算机之间的MAC地址也必须储存在帧中，所以一帧又分为标头(Head)和数据(Data)两部分。 标头(Head)存放两台计算机的MAC地址， 数据部分(Data)存放需要传输的数据。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052904.png" alt=""></p><h3 id="2-3-广播"><a href="#2-3-广播" class="headerlink" title="2.3 广播"></a><strong>2.3 广播</strong></h3><p>现在发送方知道了接收方是谁，也就是网络IP（域名），数据也写成帧的形式，那么怎么确定在众多电脑中哪台是接收方呢？以太网的方式非常简单——广播，给所有的计算机都发送数据，让其他计算机自己判断，其他计算机接受到了数据，判断是不是自己，不对就将其抛弃，对就将自己的MAC地址发送回去。具体的实现——ARP协议（在网络层介绍）</p><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a><strong>3.网络层</strong></h2><p>广播技术理论上是能成立的。但是互联网的众多计算机中，用广播的方式给每台计算机发送一个数据包明显不现实。但是我们又需要知道对方计算机的MAC地址传输数据。那么就需要缩小范围，如果是在同一子网中的计算机，用广播的方式就能够实现。所以网络层提出了一个新的概念——IP。</p><h3 id="3-1-IP协议"><a href="#3-1-IP协议" class="headerlink" title="3.1 IP协议"></a><strong>3.1 IP协议</strong></h3><p>每台计算机分配一个ip地址，目前广泛使用的是第四版，称为IPV4。由32位二进制组成，为了方便理解，我们分为四段十进制数从0.0.0.0到255.255.255.255，假设前24位为网络部分，后8位为主机部分。假设我们有一个ip地址为：192.168.0.123，那么192.168.0.*  ， 都为同一子网。该子网最多为2^8=256台， 如何确定多少位是网络多少位是主机呢？——子网掩码。</p><h3 id="3-2-子网掩码"><a href="#3-2-子网掩码" class="headerlink" title="3.2 子网掩码"></a><strong>3.2 子网掩码</strong></h3><p>1&amp;1 = 1, 1&amp;0=0, 0&amp;0 = 0。 假设24位为网络部分，那么子网掩码为:1111 1111. 1111 1111.1111 1111.0000 0000 = 255.255.255.0, ip1 和ip2 两个ip是否在同一子网呢？ ip1 &amp; 子网掩码 == ip2&amp; 子网掩码，那么就是在同一子网。192.168.0.123&amp;255.255.225.0 = 192.168.0.0。</p><h3 id="3-3-网关-gateway-和ARP协议"><a href="#3-3-网关-gateway-和ARP协议" class="headerlink" title="3.3  网关(gateway)和ARP协议"></a><strong>3.3  网关(gateway)和ARP协议</strong></h3><p>我们已知ip地址，那么就会碰到两种情况： 1.不在同一子网: 发送方将数据交给自己的网关，网关再去找到接受方ip的网关，然后就是在同一子网的情况了。 2.在同一子网:根据ARP协议，用广播的方式发送给接收方，接收方回应后得到接收方的MAC地址。 网关：网关实质上是一个网络通向其他网络的IP地址，有兴趣可以去查看一下DHCP服务器的实现原理。给一张百度的图片来理解： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/8ad4b31c8701a18be9fc814f9e2f07082838fe9f.jpg" alt=""> ARP协议：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到该子网的网络上的所有主机，所有主机确认该IP是否是自己本身，不是则抛弃该信息，是的话接收返回自身的MAC地址，以此确定目标的物理地址。</p><h3 id="3-4-IP数据包"><a href="#3-4-IP数据包" class="headerlink" title="3.4  IP数据包"></a><strong>3.4  IP数据包</strong></h3><p>根据以太网协议，数据包的单位为：帧： head+data， head中存放了MAC地址，但是我们又需要ip地址才能查找到。所以我们将数据部分继续拆分为head+data。head中存放ip地址。所以一帧数据变成了：head+head+data。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052910.png" alt=""></p><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4  传输层"></a><strong>4  传输层</strong></h2><p>我们已经知道ip和mac地址，我们可以准确的找到我们需要发送数据的那台计算机，但是计算机接受了数据怎么判断数据是交给哪个应用的呢？网上听歌和看电影那么传送过来的数据是歌曲应用的还是电影应用的呢？ ——端口。</p><h3 id="4-1-端口："><a href="#4-1-端口：" class="headerlink" title="4.1 端口："></a><strong>4.1 端口：</strong></h3><p>计算机可以选择0到65535个端口，正好16个二进制位。0到1023的端口被系统占用，用户程序可以在1024~65535端口之间选择一个。用户计算机端口与服务器计算机端口相连接，然后就可以传输数据了。</p><h3 id="4-2-UDP、-TCP-协议"><a href="#4-2-UDP、-TCP-协议" class="headerlink" title="4.2 UDP、**TCP**协议"></a><strong>4.2 UDP、**</strong>TCP<strong>**协议</strong></h3><p>如你所料，端口号当然也是要保存到数据包中，所以就有了UDP协议和TCP协议。UDP和TCP协议也同样继续将data分为head和data。head中存放端口号信息。 UDP协议：几乎就是简单的将端口号放入head中，数据没有安全保障，也容易丢包，但是传输速度非常快。比较适合语音，视频这类数据传播。 TCP协议：比较安全的将一些信息放入head中，通过协议不会丢包，通过三次握手保证信息的安全。是比较安全的一种协议。但是因为安全所以传输速度较慢。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052912.png" alt=""> 这时候一帧数据就变成了上面这样。 了解了上面的内容也许就能对ip地址有了一定的了解了，下面的图片应该看得懂了，DNS是将域名转化为IP地址一台服务器计算机。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180127161219.png" alt=""></p><h2 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a><strong>5.应用层</strong></h2><p>不同的应用需要的数据都是不同的，向FTP传输数据格式，和邮件传输通过SMTP格式。应用层就是这些数据格式的协议组成的。为用户提供各种服务。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052913.png" alt=""></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h1><p>物理层：构成互联网基础，使得所有计算机能够物理连接在一起。 数据链路层：以太网协议，数据分为帧传递。Head存放计算机的MAC地址 网络层：IP协议，数据再次细分，Head存放计算机的ip地址 传输层：TCP或UDP协议，数据再细分， 确定数据端口。Head存放了端口号。 应用层：处理数据，为应用提供服务，使得用户能够明白和使用。</p><h1 id="我的简单理解："><a href="#我的简单理解：" class="headerlink" title="我的简单理解："></a><strong>我的简单理解：</strong></h1><p>我的IP为192.168.0.111 ——&gt;浏览器访问 <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>  , 通过域名解析(DNS)为 115.239.211.112， 通过子网掩码255.255.255.0 发现我的IP和百度的IP不在同一子网，所以本机发送一个数据包【（本机MAC地址，不知百度MAC地址），（本机的IP地址， 百度的IP地址）（TCP请求的端口）（请求正文）】的请求提交给网关(gateway)，网关去找到115.239.211.112。然后百度的服务器返回一个MAC地址。通过tcp协议三次握手建立连接。 致谢：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">阮一峰的网络日志</a> 以上内容参考至阮一峰网络日志，需要更加详细了解可以去看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot;&gt;&lt;a href=&quot;#概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot; class=&quot;headerlink&quot; title=&quot;概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot;&gt;
      
    
    </summary>
    
      <category term="网络" scheme="https://ipanyiwen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="协议" scheme="https://ipanyiwen.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>笔记: AJAX</title>
    <link href="https://ipanyiwen.github.io/2018/01/25/e7-ac-94-e8-ae-b0-ajax/"/>
    <id>https://ipanyiwen.github.io/2018/01/25/e7-ac-94-e8-ae-b0-ajax/</id>
    <published>2018-01-25T08:11:05.000Z</published>
    <updated>2018-07-02T06:28:16.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 <strong>Question：</strong> 当注册一个网页的时候，填写完用户名，文本框刚刚失去焦点，马上提示该用户已经被注册。这肯定是访问了后台，但是页面也没有刷新呀。一般是用了AJAX。不重新加载整个页面的情况下与服务器进行交互。 <strong>语法：</strong> <strong>1. JavaScript：</strong></p><pre><code>function getInfo(){    var xmlhttp;    if (window.XMLHttpRequest){            // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码        xmlhttp=new XMLHttpRequest();    }else{    // IE6, IE5 浏览器执行代码        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    }    xmlhttp.onreadystatechange=function(){        if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){                 var str = xmlhttp.responseText;                 alter(str);        }    }    xmlhttp.open(&quot;GET&quot;,&quot;/url&quot;,true);    xmlhttp.send();}</code></pre><p>代码解释：(以Java为例！) 首先是执行最下面的xmlhttp.open();之后发送给服务器处理，处理完成后执行<code>onreadystatechange=function(){}</code> ，在其中操作。 xmlhttp.open()的三个参数分别是：执行get/post方法，访问的URL地址， 是否为异步请求。 第一个参数： GET，<code>xmlhttp.open(&quot;GET&quot;,&quot;/url&quot;,true);</code>  向服务器发送数据就只能在URL中带过去，/url?data=123; POST ，<code>xmlhttp.open(&quot;POST&quot;,&quot;/url&quot;,true);</code> 向服务器发送数据方法，<code>需要设置一下请求头, setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //`</code>以form表单的形式提交，后台就可以像接受form表单数据一样接受数据。  xmlhttp.send(“data=123”);<code>再向服务器发送数据。 第二个参数: /url    访问服务器的servlet。 第三个参数: true 为异步操作，方法写在</code>onreadystatechange=function(){}<code>中。 false为同步操作, 方法直接写在send的后面，不需要</code>onreadystatechange<code>解释：</code>xmlhttp.readyState==4` readyState从 0 到 4 发生变化。</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul><p>status为访问状态，404 页面没找到， 500 内部错误， 200访问正常等。</p><ul><li>1xx  -消息: 请求正在处理，请稍后。。。</li><li>2xx -成功处理</li><li>3xx -重定向到其他地方: 需要客户端再次发送请求</li><li>4xx -客户端错误，eg: 非法的资源请求，禁止访问</li><li>5xx -服务器段错误 ，eg: 服务器抛出异常</li></ul><p>在Java中将处理结果的字符串，一般是以JSON字符串返回，存储在前端xmlhttp.responseText中。 <strong>2.  jQuery写法：</strong> jquery将上述写法进行了封装，使得我们更加简单和方便的去使用ajax。常见用法：</p><p>$.ajax(function(){<br>    type: “post”,<br>    url : “url”,<br>    data: {“name”:”Peter”},<br>    success:function(data, status){<br>       //处理<br>    },<br>    error:function(){<br>        //error有三个参数，可以依据情况需要写<br>    }<br>});</p><p>jquery还专门封装了$.get() 和 $.post()的ajax用法，分别执行get和post。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;&lt;strong&gt;概念：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;AJAX = Asynchronous JavaScript and XML（异步的 JavaSc
      
    
    </summary>
    
      <category term="JavaScript|JQuery" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/"/>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ajax" scheme="https://ipanyiwen.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript笔记: JSON</title>
    <link href="https://ipanyiwen.github.io/2018/01/25/javascript-e7-ac-94-e8-ae-b0-json/"/>
    <id>https://ipanyiwen.github.io/2018/01/25/javascript-e7-ac-94-e8-ae-b0-json/</id>
    <published>2018-01-25T07:05:15.000Z</published>
    <updated>2018-07-02T00:38:39.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念：</strong> JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。 <strong>语法：</strong> JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值。</p><p>{“key”:value}<br>等价于JavaScript的<br>{key : value}</p><p><strong>重点：</strong> <strong>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</strong> <strong>JSON 语法非常简单, 简单记住三种: {} 和 [] 和 :</strong> <strong>一对大括号, 代表一个对象, {id : 1, name:’xiaoming’}</strong> <strong>一对中括号, 代表一个数组, [{id : 1, name:’xiaoming’}, {id : 2, name:’xiaohong’}]</strong> <strong>  冒号,  冒号前是key, 后是value.</strong> JSON与JS对象之间的转化方式：</p><p>要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  var json = JSON.stringify(&#123;a: </span><br><span class="line">&apos;Hello&apos;</span><br><span class="line">, b: </span><br><span class="line">&apos;World&apos;</span><br><span class="line">&#125;); </span><br><span class="line">  结果：&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>要实现从 JSON 转换为对象，使用 JSON.parse() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  var obj = JSON.parse(</span><br><span class="line">&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  结果： &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>JSON 数组：</strong></p><p>写在方括号中,{key : [value1_key : value, value2_key : value, …]}</p><p>{<br>“employees”: [<br>{ “firstName”:”John” , “lastName”:”Doe” },<br>{ “firstName”:”Anna” , “lastName”:”Smith” },<br>{ “firstName”:”Peter” , “lastName”:”Jones” }<br>]<br>}</p><p>因为json是一个字符串，所以传输起来比较快。解析起来也方便，web中常常用的到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt; JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。 &lt;strong&gt;语法：&lt;/strong&gt; JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同
      
    
    </summary>
    
      <category term="JavaScript|JQuery" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/"/>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="json" scheme="https://ipanyiwen.github.io/tags/json/"/>
    
  </entry>
  
</feed>
