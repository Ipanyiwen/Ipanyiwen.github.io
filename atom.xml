<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Pan</title>
  
  <subtitle>读书随处净土，闭门即是深山.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://ipanyiwen.github.io/"/>
  <updated>2018-07-01T12:22:23.959Z</updated>
  <id>https://ipanyiwen.github.io/</id>
  
  <author>
    <name>Pan yiwen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>wordpress使用 Font Awesome 图标在 Firefox 中不显示问题</title>
    <link href="https://ipanyiwen.github.io/2018/06/26/wordpress-e4-bd-bf-e7-94-a8-font-awesome-e5-9b-be-e6-a0-87-e5-9c-a8-firefox-e4-b8-ad-e4-b8-8d-e6-98-be-e7-a4-ba-e9-97-ae-e9-a2-98/"/>
    <id>https://ipanyiwen.github.io/2018/06/26/wordpress-e4-bd-bf-e7-94-a8-font-awesome-e5-9b-be-e6-a0-87-e5-9c-a8-firefox-e4-b8-ad-e4-b8-8d-e6-98-be-e7-a4-ba-e9-97-ae-e9-a2-98/</id>
    <published>2018-06-26T07:41:33.000Z</published>
    <updated>2018-07-01T12:22:23.959Z</updated>
    
    <content type="html"><![CDATA[<p><strong>问题:</strong>  换了个主题后发现一些图标的不显示。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/06/LO43X4C46DIXN8N4ISJ@N6-300x111.png" alt=""> <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/06/QQ图片20180626150908-300x48.png" alt=""> 解决方案： 由于字体跨域导致。 由于我的是apache2服务器。 进入配置文件：</p><pre><code>sudo vim /etc/httpd/conf/httpd.conf </code></pre><p>添加</p><pre><code>Header set Access-Control-Allow-Origin * </code></pre><p>问题解决！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;问题:&lt;/strong&gt;  换了个主题后发现一些图标的不显示。 &lt;img src=&quot;http://120.78.85.68/wordpress/wp-content/uploads/2018/06/LO43X4C46DIXN8N4ISJ@N6-300x111
      
    
    </summary>
    
      <category term="随笔" scheme="https://ipanyiwen.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
  </entry>
  
  <entry>
    <title>堆排序</title>
    <link href="https://ipanyiwen.github.io/2018/05/26/e5-a0-86-e6-8e-92-e5-ba-8f/"/>
    <id>https://ipanyiwen.github.io/2018/05/26/e5-a0-86-e6-8e-92-e5-ba-8f/</id>
    <published>2018-05-26T13:48:56.000Z</published>
    <updated>2018-07-02T06:27:06.748Z</updated>
    
    <content type="html"><![CDATA[<h2 id="堆的定义"><a href="#堆的定义" class="headerlink" title="堆的定义"></a>堆的定义</h2><blockquote><p>堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象。堆总是满足下列性质：堆中某个节点的值总是不大于或不小于其父节点的值；堆总是一棵完全二叉树。</p></blockquote><h3 id="大根堆"><a href="#大根堆" class="headerlink" title="大根堆"></a>大根堆</h3><p>将根节点最大的堆叫做最大堆或大根堆，在这颗完全二叉树中,所有根节点都大于两个子节点. <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/05/2018-05-26-21-47-47-的屏幕截图.png" alt=""></p><h3 id="小根堆"><a href="#小根堆" class="headerlink" title="小根堆"></a>小根堆</h3><p>根节点最小的堆叫做最小堆或小根堆。在这颗完全二叉树中,所有根节点都小于两个子节点. <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/05/2018-05-26-21-46-50-的屏幕截图.png" alt=""></p><h4 id="堆的定义如下："><a href="#堆的定义如下：" class="headerlink" title="堆的定义如下："></a>堆的定义如下：</h4><p>n个元素的序列{k1,k2,ki,…,kn}当且仅当满足下关系时，称之为堆。 小根堆: (ki &lt;= k2i,ki &lt;= k2i+1)或者 大根堆: (ki &gt;= k2i,ki &gt;= k2i+1), (i = 1,2,3,4…n/2)</p><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>给定一个大根堆的二叉树. 每次将堆顶元素取出, 放入有序集合. 将堆低元素放入堆顶,重新将该树构造大根堆,重复上诉过程,即可得到一个有序集合.</p><h4 id="算法思路"><a href="#算法思路" class="headerlink" title="算法思路:"></a>算法思路:</h4><ol><li>构造大根堆.</li><li>取堆顶元素(即最大值)放入有序集合中, 将堆低元素放入堆顶,此时该二叉树可能不满足堆,故需要重新构建堆.</li><li>重复步骤2,直到构造完成.</li></ol><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现:"></a>代码实现:</h4><pre><code>/**   * 调整堆   * @param poi 需要调整的数字位置 *   * @param a 数组-&gt; 模拟堆 *   * @param len 数组长度, 堆元素个数   * */  public static void adjustHeap(int poi, int a[], int len){      int temp = a[poi];      for (int i = poi*2+1; i &lt; len; i=i*2+1) {          if (i+1 &lt; len &amp;&amp; a[i] &lt; a[i+1]) {              i++;          }          if(temp &lt; a[i]){              a[poi] = a[i];              poi = i;          }else {              break;          }      }      a[poi] = temp;  }  /** * 堆排序 *   * @param a 数组-&gt; 模拟堆 *   * @param len 数组长度, 堆元素个数   * */  public static void heapsort(int a[], int len){      for(int i = len/2-1; i &gt;= 0; i--){          adjustHeap(i, a, len);      }      for(int i = len-1; i &gt; 0; i--){          int temp = a[0];          a[0] = a[i];          a[i] = temp;          adjustHeap(0, a, i);      }  }</code></pre><h4 id="构造大根堆分析"><a href="#构造大根堆分析" class="headerlink" title="构造大根堆分析:"></a>构造大根堆分析:</h4><p>由于二叉树的叶子节点数为: n0 = (n+1)/2 //该除2是不会计算小数,也就是计算机中的除2 所以非叶子节点树为: n1 = n - n0 = n/2. //在计算机语言中是n/2 由于数组是从0开始, 所以我们需要构造大根堆时是从n/2 -1 到 0,即构造所有非叶子节点.  </p><h5 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析:"></a>算法分析:</h5><p>时间复杂度: O(nlog(n)) 总时间复杂度: O(nlog(n)) 初始化大根堆时间复杂度分析:</p><p>树的深度: k = log(n)  =&gt; 2^k = n</p><p>  最坏的情况在第i层  有2^(i-1) 个节点, 往下k-i次替换.  所以时间复杂度:<br>s = 2^(i-1) <em> (k-i)  |  i -&gt; (k-1 ~ 1)<br>展开:  s = 2^(k-2) </em> 1 + 2^(k-3) <em> 2 + 2^(k-4) </em> 3 + … + 2^0 <em> (k-1)<br>两边同时乘2:  2s = 2^(k-1)  + 2^(k-2) </em> 2 + 2^(k-3) <em> 3 + … + 2^1 </em> (k-1)<br>2式减1式: s = (2^(k-1) + 2^(k-2) + 2^(k-3) + … + 2^1) - (k-1) =  2*(1-2^(k-1))/(1-2) - (k-1) = 2^k - k - 1<br>所以s的时间复杂度: n - log(n) - 1  =&gt;  O(n)</p><p>总时间复杂度: 循环n-1次,最坏的情况每次都从1到k, 每层都换,也就是log(n)次, 所以时间复杂度为: (n-1) * log(n) 所以总时间复杂度: O(nlog(n)).   空间复杂度:O(1) 稳定性: 不稳定的排序算法.</p><h4 id="作用"><a href="#作用" class="headerlink" title="作用:"></a>作用:</h4><p>堆排序可以用来排序, 但大多数时候不如快排 可是当数据量巨大, 如百万级别的时候, 快排的递归调用可能会使堆栈溢出.而堆排序O(1)的空间复杂度,还没有递归调用, 就十分合适了. 还可以用来实现优先队列.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;堆的定义&quot;&gt;&lt;a href=&quot;#堆的定义&quot; class=&quot;headerlink&quot; title=&quot;堆的定义&quot;&gt;&lt;/a&gt;堆的定义&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;堆（英语：heap)是计算机科学中一类特殊的数据结构的统称。堆通常是一个可以被看做一棵树的数组对象
      
    
    </summary>
    
      <category term="算法" scheme="https://ipanyiwen.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://ipanyiwen.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>C语言_07 内存</title>
    <link href="https://ipanyiwen.github.io/2018/03/21/c-e8-af-ad-e8-a8-80-07-e5-86-85-e5-ad-98/"/>
    <id>https://ipanyiwen.github.io/2018/03/21/c-e8-af-ad-e8-a8-80-07-e5-86-85-e5-ad-98/</id>
    <published>2018-03-20T16:10:45.000Z</published>
    <updated>2018-07-02T06:26:13.547Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性"><a href="#前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性" class="headerlink" title="前言: 程序的执行是放入内存中的,而我们在写代码时定义的变量, 函数等是存储在内存的不同区域. 不同的区域有着不同的特性."></a>前言: 程序的执行是放入内存中的,而我们在写代码时定义的变量, 函数等是存储在内存的不同区域. 不同的区域有着不同的特性.</h4><h3 id="参考资料和网上所说的内存分区大致可以分为两种-分四个区和分五个区"><a href="#参考资料和网上所说的内存分区大致可以分为两种-分四个区和分五个区" class="headerlink" title="参考资料和网上所说的内存分区大致可以分为两种: 分四个区和分五个区."></a>参考资料和网上所说的内存分区大致可以分为两种: 分四个区和分五个区.</h3><h4 id="1-四区-栈区-堆区-全局-静态-区-常量-代码-区"><a href="#1-四区-栈区-堆区-全局-静态-区-常量-代码-区" class="headerlink" title="1.四区: 栈区, 堆区, 全局(静态)区, 常量(代码)区."></a>1.四区: 栈区, 堆区, 全局(静态)区, 常量(代码)区.</h4><h4 id="2-五区-栈区-堆区-全局-静态-区-常量区-代码区"><a href="#2-五区-栈区-堆区-全局-静态-区-常量区-代码区" class="headerlink" title="2.五区: 栈区, 堆区, 全局(静态)区, 常量区. 代码区."></a>2.五区: 栈区, 堆区, 全局(静态)区, 常量区. 代码区.</h4><p>其实这两者就是将最后一个区分为常量区和代码区.我们介绍的话就以五区来介绍吧. 主要将最后的那个区分开理解就好. 当然还有一种分四区: 栈区, 堆区, 数据区, 代码区. 将数据区细分为全局(静态)区, 常量区.虽然这样分很好理解,但是并不那么贴切(个人感觉). 来张图片理解一下(随便百度的): 最上面的计算机内核使用的归操作系统,虽然和我们编写程序没什么关系,但是也要了解以下.</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/1132092356331491654.jpg" alt=""></p><h2 id="内存五区"><a href="#内存五区" class="headerlink" title="内存五区:"></a>内存五区:</h2><h3 id="1-栈区"><a href="#1-栈区" class="headerlink" title="1.栈区:"></a>1.栈区:</h3><p>栈区,是我们最常用到的区域, 因为我们所有的普通局部变量全部存储在这个区.就如我们定义和使用局部变量一样. 在栈区的数据是不需要我们手动去申请和释放内存的. 这个过程全部由编译器帮我们完成,所以我们的局部变量可以直接使用.</p><pre><code>int func(int x, int y){   //传递过来的参数 在栈区    int z = x + y;     //函数内部定义的局部变量在栈区    return z;}int main(){    int a = 3;    //函数内部定义的局部变量在栈区    a += 2;    return 0;}</code></pre><h3 id="2-堆区"><a href="#2-堆区" class="headerlink" title="2.堆区:"></a>2.堆区:</h3><p>堆区,凡是手动malloc realloc calloc, 或者 C++中的new出来的变量都是存储在堆区. 如果学过数据结构或者用过C++的话就会知道, 数据结构中的链表是任意长度的,我们用c实现的话每个节点都是通过malloc函数创建出来的.而C++的话我们new出来的对象都是局部对象, 这些都是我们自己手动申请创建的内存.</p><h4 id="注意-我们手动申请的在堆区的时候-如果我们不手动释放-free-掉这段内存-这段内存会一直占用直到程序结束-手动释放掉内存后切记将该指针置空"><a href="#注意-我们手动申请的在堆区的时候-如果我们不手动释放-free-掉这段内存-这段内存会一直占用直到程序结束-手动释放掉内存后切记将该指针置空" class="headerlink" title="注意: 我们手动申请的在堆区的时候,如果我们不手动释放(free)掉这段内存, 这段内存会一直占用直到程序结束. 手动释放掉内存后切记将该指针置空."></a><em>注意: 我们手动申请的在堆区的时候,如果我们不手动释放(free)掉这段内存, 这段内存会一直占用直到程序结束. 手动释放掉内存后切记将该指针置空.</em></h4><p>当然C++通过new 出来的对象系统会自动调用析构函数释放内存.</p><pre><code>int *func(int x, int y){  //x y, 是在栈区    int *p = malloc(4);  //p所指向的内存就存放在堆区.    *p = x+y;    return p;}int main(){    int *p = NULL;    p = func(3, 5);    printf(&quot;%d\n&quot;, *p);    free(p); //使用完后释放内存, 并将p置空    p = NULL;    //后续代码操作    return 0;}</code></pre><h3 id="3-全局-静态-区"><a href="#3-全局-静态-区" class="headerlink" title="3.全局(静态)区:"></a>3.全局(静态)区:</h3><p>全局(静态)区:故名思义,全局变量和静态变量(static)存放的在这个区.这个区域也叫可读写区, 分为.data和.bss两部分, 1 .data段(初始化全局|静态变量), 所有初始化了的全部变量存放的区域.则为数据分配空间，数据保存在目标文件中。 2 .bss段(未初始化全局|静态变量), 所有未初化的全部变量存放的区域.不给该段的数据分配空间，只是记录数据所需空间的大小。 <em>注意: 如果我们定义了一个全部整型变量并赋予了初始值0, 如果我们不给其赋值编译器也会在使用时赋予初始值0, 为了优化会将其放入.bss段, 当作未初始化处理.(看到有人的帖子这样说的,但是我不会验证 TAT!)</em> 附上帖子地址: <a href="http://blog.csdn.net/u010154760/article/details/46552303" target="_blank" rel="noopener">http://blog.csdn.net/u010154760/article/details/46552303</a></p><pre><code>int a;      //全局(静态)区//int a = 0;  //据说都是在.bss段int b = 2; //全局(静态)区,  .data段void static fun_sta(){   //这个函数是存放在代码区的. }void func(){    static int a = 0;  //全局(静态)区.  额,这个应该也是在.bss吧.不知道有没有好心人告知一波...    static int b = 1; //全局(静态)区.  .data段}int main(){    static int a = 3;  //全局(静态)区 .data段    return 0;}</code></pre><h3 id="4-常量区"><a href="#4-常量区" class="headerlink" title="4.常量区:"></a>4.常量区:</h3><p>常量区: (也叫文字常量区)我们在程序中使用的一些整型常量, 浮点型常量, 还有一个很容易误会的字符串常量都是存放在常量区. 举个简单的例子: int a = 4; 我们知道a是存放在栈区的, &amp;a的地址就是栈区的地址, 但是4却是存放在常量区.画图帮助理解.<br><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/changliangqu.png" alt=""> </p><p>普通的常量很好理解, 但是字符串有点特殊.举个例子.</p><pre><code>int main(){    char *s = &quot;abc&quot;;   //字符串    char *s1 = &quot;abc&quot;;   //字符串    char s2[] = &quot;abc&quot;;  //字符串数组    printf(&quot;%p\n&quot;, s);    printf(&quot;%p\n&quot;, s1);    printf(&quot;%p\n&quot;, s2);    return 0;}</code></pre><p>输出结果:</p><pre><code>panyiwen@god:~/temp$ ./a.out 0x4006b40x4006b40x7ffe50893e90</code></pre><p><em>可以看出指针s 和 s1指向的是同一个地址, 而s2和前两个都不同. 原因就是: s 和 s1 都是指向常量区的地址, 常量区只有一个字符串”abc”, 而s2是一个普通的局部变量数组, 那么s2就是存储在栈区的一个字符串</em> 画图理解: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/string.png" alt=""></p><h3 id="5-代码区"><a href="#5-代码区" class="headerlink" title="5 代码区:"></a>5 代码区:</h3><p>代码区: 故名思义, 所有的代码是存放在这里.而且是编译后的二进制代码.当然这个区是由操作系统直接控制.</p><h4 id="代码区和常量区因为都是不可修改的-所以这两个区也被合并在一块称之为只读区"><a href="#代码区和常量区因为都是不可修改的-所以这两个区也被合并在一块称之为只读区" class="headerlink" title="代码区和常量区因为都是不可修改的, 所以这两个区也被合并在一块称之为只读区."></a><em>代码区和常量区因为都是不可修改的, 所以这两个区也被合并在一块称之为只读区.</em></h4><p>再放入一张横向图片供参考.<br><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/1356942710_5027.jpg" alt=""> </p><p>鸣谢:<br><a href="http://blog.csdn.net/czg13548930186/article/details/52766606" target="_blank" rel="noopener">http://blog.csdn.net/czg13548930186/article/details/52766606</a><br><a href="http://blog.csdn.net/androidxiaogang/article/details/50383516" target="_blank" rel="noopener">http://blog.csdn.net/androidxiaogang/article/details/50383516</a><br><a href="http://blog.csdn.net/u010672206/article/details/46946593" target="_blank" rel="noopener">http://blog.csdn.net/u010672206/article/details/46946593</a> </p><p>希望能让你能有所收获, 不对的地方还请多多指教.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性&quot;&gt;&lt;a href=&quot;#前言-程序的执行是放入内存中的-而我们在写代码时定义的变量-函数等是存储在内存的不同区域-不同的区域有着不同的特性&quot; clas
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_06 指针</title>
    <link href="https://ipanyiwen.github.io/2018/03/20/c-e8-af-ad-e8-a8-80-06-e6-8c-87-e9-92-88/"/>
    <id>https://ipanyiwen.github.io/2018/03/20/c-e8-af-ad-e8-a8-80-06-e6-8c-87-e9-92-88/</id>
    <published>2018-03-19T18:37:00.000Z</published>
    <updated>2018-07-02T06:25:58.499Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p><strong>指针</strong>（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（points to）存在电脑存储器中另一个地方的值。由于通过地址能找到所需的变量单元，可以说，地址指向该变量单元。因此，将地址形象化的称为“指针”。意思是通过它能找到以它为地址的内存单元。</p></blockquote><p>我们都知道, 在计算机语言中, 变量是储存在计算机的内存中的, 所以C程序想要访问得到变量必须知道储存在计算机内存中的什么位置, 在C程序中用来存储这个位置的变量就是指针.</p><h2 id="指针的定义方法"><a href="#指针的定义方法" class="headerlink" title="指针的定义方法:"></a>指针的定义方法:</h2><pre><code>int *p = NULL;   //定义一个整型指针.char *p1 = NULL; //定义一个char型指针double *p2 = NULL;  //定义一个浮点型指针</code></pre><p>定义指针和定义一个变量一样, 不过变量名前面加上一个星号(*), 表示这是一个什么类型的指针.</p><h3 id="取地址符-amp-和指针运算符"><a href="#取地址符-amp-和指针运算符" class="headerlink" title="取地址符: &amp; 和指针运算符 *"></a>取地址符: &amp; 和指针运算符 *</h3><h4 id="取地址符-amp"><a href="#取地址符-amp" class="headerlink" title="取地址符 &amp;:"></a>取地址符 &amp;:</h4><pre><code>int a=3;int *p = &amp;a;   //取a的地址, 赋值给一个同类型的指针scanf(&quot;%d&quot;, &amp;a);  //我们输入一个整数需要存放进内存,所以我们必须知道将这个整数存放在内存的什么位置(地址).</code></pre><h4 id="指针运算符"><a href="#指针运算符" class="headerlink" title="指针运算符 *:"></a>指针运算符 *:</h4><pre><code>int a = 3;int *p = &amp;a;    //定义一个指针p,并将a的地址赋值给p, 这里的* 只是告知编译器定义的是一个指针变量.//我们取得a的地址给了p,但是我们怎么取得a的值呢?  --指针运算符int b = *p+3;    //效果相当于: int b = a + 3;  也相当与 int b = *&amp;a + 3;</code></pre><p>看到这里其实可以发现,我们平时定义的int a = 3; a = a + 3; 这个a被C语言简化隐藏起来了 *(&amp;a), 找到a的地址, 然后取出该地址中存放的值.再对这个值进行操作.</p><h2 id="指针和指针变量"><a href="#指针和指针变量" class="headerlink" title="指针和指针变量"></a>指针和指针变量</h2><p>1.指针:上面我们知道指针其实就是一段地址. 一个变量int a, 那么a的内存地址就是指针. 2.指针变量: 用来存放指针(地址)的变量. 举个栗子:</p><pre><code>int a = 4;int *p = &amp;a;   //取a的地址;</code></pre><p>这个p就是指针变量, a的地址(&amp;a)就是指针. 也就是指针变量指向的地址就是指针,存放这个地址的变量就是指针变量.</p><h4 id="重点-指针变量中存放的地址-这个地址是指变量的首地址"><a href="#重点-指针变量中存放的地址-这个地址是指变量的首地址" class="headerlink" title="重点: 指针变量中存放的地址, 这个地址是指变量的首地址."></a><em>重点: 指针变量中存放的地址, 这个地址是指变量的首地址.</em></h4><pre><code>int a = 3;       //整型占四个字节. 如果a在内存中的位置是1000 ~ 1003int *p = &amp;a;   // 那么p = 1000, 因为是整型指针变量, 所以系统就知道1000~1003都是p所指向的东西.</code></pre><h2 id="指向指针的指针"><a href="#指向指针的指针" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h2><h3 id="指针变量的地址"><a href="#指针变量的地址" class="headerlink" title="指针变量的地址"></a>指针变量的地址</h3><p>我们知道指针变量也是存放在内存中的一个变量,那么存放在内存中,就有地址,这个就是指针的地址. int *p = &a; 那么p == &a; 指针变量的地址: &p;</p><h3 id="指向指针的指针-1"><a href="#指向指针的指针-1" class="headerlink" title="指向指针的指针"></a>指向指针的指针</h3><p>我们通常定义的指针: int a = 3; int *p = &a;这个p指向的是整型变量a的地址. 那么指针变量p的地址: &amp;p用什么来存.</p><pre><code>int a = 3;int *p = &amp;a;//不能用 int *p1 = &amp;p;会报错,正确的方法: int **p1 = &amp;p;    //p1就是指向指针的指针.//所以我们得到p1, 怎么得到3呢? // *p1 == p == &amp;a// *(*p1) == *p == a == 3, 括号可以省略int b = **p1 + 3;</code></pre><h2 id="数组与指针的关系"><a href="#数组与指针的关系" class="headerlink" title="数组与指针的关系"></a>数组与指针的关系</h2><p>我们知道数组是一系列相同数据的集合, 我们通常定义一个数组: int a[4] = {1, 2, 3, 4}; 然后我们就可以通过下标任意访问数组中的任意一个元素, a[0] == 1, a[1] == 2. 但其实数组名就是一个有着特殊用法的指针. 举个例子</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int b = a[0] + 2;  //访问数组中的第一个元素.int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;第一个元素的地址: %p\n&quot;, p);  //打印第一个元素的地址.printf(&quot;a的地址: %p\n&quot;, a);  //打印aprintf(&quot;p指向的地址的值: %d\n&quot;, *p); //打印p指向的地址的值printf(&quot;a指向的地址的值: %d\n&quot;, *a); //打印a指向的地址的值</code></pre><p>结果:</p><pre><code>panyiwen@god:~/temp$ ./a.out 第一个元素的地址: 0x7ffc259b5b20       a的地址: 0x7ffc259b5b20p指向的地址的值: 1a指向的地址的值: 1</code></pre><p>我们会发现数组a其实就是一个指向数组第一个元素首地址的指针.因为我们定义了int a[4]; 所以系统就会为a开辟一个连续的占4个整型的内存.a就是这段内存的开始地址, 例子:</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;%d\n&quot;, a[1]);  //输出第二个元素printf(&quot;%d\n&quot;, *(p+1));  //同样可以输出第二个元素  //输出结果都是2//(指针类型+1)指加一个同样类型的长度, int 类型的p+1 相当于后移动4位, char 类型的p+1就相当于移动了1位</code></pre><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/03/point.png" alt=""> 假设a的地址就是1000, 那么p+1就是1004, 也就是第二个元素的首地址, 这样我们就应该明白了,所谓的一对中括号[]运算符, 就是指针走到第n个位置并取出里面的值.只是c语言进行了封装.举个例子验证一下:</p><pre><code>int a[4] = {1, 2, 3, 4};  //定义一个数组int *p = &amp;a[0];    //取第一个元素的地址printf(&quot;%d\n&quot;, a[1]);  //输出第二个元素printf(&quot;%d\n&quot;, p[1]);  //同样可以输出第二个元素  相当于*(p+1)</code></pre><p>一个指针也同样可以使用[]运算符. 输入结果和之前是一样的.</p><h4 id="二维数组与指针"><a href="#二维数组与指针" class="headerlink" title="二维数组与指针:"></a>二维数组与指针:</h4><p>二维数组:int a[2][2] = { {1, 2}, {3, 4}}; 在内存中仍然是开辟4个连续的int型空间.但是和int a[4] = {1, 2, 3, 4} 在存储上没什么区别, 但是意义却不同. int a[2][2]; 可以理解为: a[0] -&gt; {1, 2} a[1] -&gt; {3, 4} a[0], a[1] 均为指针变量. 而a - &gt; int *tmp[] = {a[0], a[1]}; tmp为存放指针的数组, 所以a是一个指向指针数组的指针.</p><h4 id="重点-但是a中存放的并不是一个新的指针数组-tmp-所在的地址-而是原来数组的首位地址-所以如果我们用int-p来指代a是不对的"><a href="#重点-但是a中存放的并不是一个新的指针数组-tmp-所在的地址-而是原来数组的首位地址-所以如果我们用int-p来指代a是不对的" class="headerlink" title="重点: 但是a中存放的并不是一个新的指针数组(tmp)所在的地址, 而是原来数组的首位地址,所以如果我们用int **p来指代a是不对的."></a><em>重点: 但是a中存放的并不是一个新的指针数组(tmp)所在的地址, 而是原来数组的首位地址,所以如果我们用int **p来指代a是不对的.</em></h4><pre><code>//所以下面两个其实是不一样的.int a[2][2] = { {1, 2}, {3, 4}};int **p = a;   //a是第一个元素的首地址, 所以a == &amp;a[0][0]//所以*p == *(&amp;a[0][0]) == a[0][0] = 1//所以**p == *1, 取地址为1中的数据, 就会出现错误.//正确用法其实是: int *p = a; // 然后根据二维数组的位置直接取就可以了.int b = *(p+1*2+0)+1; // 相当于 int b = a[1][0] + 1;//而a就是我们理解指向指针数组的指针. printf(&quot;%p\n&quot;, *(a+1));printf(&quot;%p\n&quot;, a[1]);//这两者是一样的.</code></pre><h2 id="结构体与指针"><a href="#结构体与指针" class="headerlink" title="结构体与指针"></a>结构体与指针</h2><p>结构体对于C来说非常重要,学C不可避免的要学习结构体, 而结构体和指针也是息息相关的.</p><blockquote><p>C语言结构体内嵌指针实现面向对象, C语言是面向过程的，但是用C语言写出的linux系统是面向对象的。 非面向对象的语言，也可以实现面向对象的代码。只是说用面向对象的语言来实现面向对象要更加简单、直观一些.而C语言实现起来复杂而已.</p></blockquote><h4 id="结构体中的指针"><a href="#结构体中的指针" class="headerlink" title="结构体中的指针:"></a>结构体中的指针:</h4><p>在结构体内部定义指针, 和普通指针一样使用.</p><pre><code>struct ln{    int *num;    //定义一个结构体中的指针.      };</code></pre><h4 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针:"></a>结构体指针:</h4><p>一个结构体类型的指针,用法和普通结构体差不多,不过访问元素用’-&gt;’ 记得先分配内存再使用!</p><pre><code>struct node{    int data;   //普通整型    int *next;  //结构体内部指针.} *no;  //可以在此处定义一个全局的结构体指针变量.//在main中的定义:int main(){    struct node *mynode;   //定义在main中的局部结构体指针变量    //指针访问内部元素时候是用-&gt;, 使用前记得先申请一个内存,    no = (struct node *)malloc(sizeof(struct node));      no-&gt;data = 1;      //或者    struct node no1；  //定义一个非指针类型.    mynode = &amp;no1;    mynode-&gt;data = 2;     return 0;}</code></pre><h2 id="函数与指针"><a href="#函数与指针" class="headerlink" title="函数与指针"></a>函数与指针</h2><h4 id="传递指针参数"><a href="#传递指针参数" class="headerlink" title="传递指针参数:"></a>传递指针参数:</h4><p>我们都知道, 函数是可以传递参数的, 如果我们以指针(地址)为参数传递呢？ 其实这就是指针优秀的地方,我们普通参数的传递,都是拷贝一份数据传给函数的形参.这就涉及到了一个很有名的例子.交换两个数.</p><pre><code>void swap(int a, int b){    int t = a;    a = b;    b = t;}int main(){    int a = 1, b = 2;    swap(a, b);    printf(&quot;a=%d, b=%d&quot;, a, b);   //a,b并没有交换. 原因就是上面所说的数据是拷贝一份传给函数的, 实际上的a, b并没有变.    return 0;}</code></pre><p>如果我们是传递指针参数</p><pre><code>void swap(int* a, int* b){    int t = *a;    *a = *b;    *b = t;}int main(){    int a = 1, b = 2;    swap(&amp;a, &amp;b);    printf(&quot;a=%d, b=%d&quot;, a, b);   //a,b交换了. a, b地址传递过去, 那么对于a, b的修改自然影响到了原来的a, b.    return 0;}</code></pre><p>这个例子在很多书上,百度都会有, 解释的比我要详细很多, 不懂的可以百度一下.所以我们传递一个数组上去时候, 传递的是数组名, 其实也就是一个指针变量, 所以函数中对数组的修改会影响到原来的数组. 指针的好处就呼之欲出了, 如果我们的数据很多很大,我们传递一个数据上去, 不需要拷贝一份.只需要一个指针, 4个字节, 8个字节就可以得到数据.加快速度节省空间.只是需要程序员考虑指针会修改原来的数据.</p><h4 id="指针函数"><a href="#指针函数" class="headerlink" title="指针函数"></a>指针函数</h4><p>返回值是一个指针的函数, 被称为指针函数.</p><pre><code>int *func(){   //返回类型后加一个*     int *p = malloc(4);   //申请堆区的内存. 使用完记得释放.    return p;   //返回值一定要是同类型的指针(地址).}</code></pre><p>这样的函数就称为指针函数. 一般是在函数中申请堆区的内存.因为如果是定义一个普通的变量, 在栈区, 由系统自动释放, 那么在函数调用完就释放了. 当然也可以声明为static,放入静态(全局)区.</p><h4 id="函数指针"><a href="#函数指针" class="headerlink" title="函数指针"></a>函数指针</h4><p>指向函数的指针变量, 其本质是一个指针变量. 其实函数也是一个存储在计算机内存中的(代码区), 既然是在内存中, 就有地址. 写法: 返回值类型 (*函数名) (参数); 举个例子:</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;}int main(){    int (*pmax)(int, int);  //声明一个函数指针    pmax = max;  //赋值    // pmax = &amp;max;  //也可以这样写.    int z = pmax(3, 4);    // int z = (*pmax)(3, 4);  //也可以这样写    printf(&quot;%d\n&quot;, z);    //输出4    return 0;}</code></pre><p>函数名其实就是函数在内存中的首地址, 知道这个就可以给函数指针赋值.由于函数指针也是一个变量, 所以我们的struct中也就可以放函数指针,使得结构体也可以调用方法.</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;}struct ln{    int data;    int (*pmax)(int, int);  //声明一个函数指针};int main(){    struct ln t;    t.pmax=max;    printf(&quot;%d\n&quot;,t.pmax(3, 4));  //结构体调用方法.    return 0;}</code></pre><p>感谢: <a href="http://nevel.cnblogs.com/p/6370264.html" target="_blank" rel="noopener">http://nevel.cnblogs.com/p/6370264.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;指针&lt;/strong&gt;（Pointer）是编程语言中的一个对象，利用地址，它的值直接指向（poin
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_05 函数详解</title>
    <link href="https://ipanyiwen.github.io/2018/02/12/c-e8-af-ad-e8-a8-80-05-e5-87-bd-e6-95-b0/"/>
    <id>https://ipanyiwen.github.io/2018/02/12/c-e8-af-ad-e8-a8-80-05-e5-87-bd-e6-95-b0/</id>
    <published>2018-02-11T19:14:34.000Z</published>
    <updated>2018-07-02T06:25:33.567Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><blockquote><p>“函数”是从英文function翻译过来的，其实，function在英文中的意思即是“函数”，也是“功能”。从本质意义上来说，函数就是用来完成一定功能的。这样对函数的概念就很好理解了，所谓函数名就是给该功能起个名字，如果该功能是用来实现数学运算的，就是数学函数。</p></blockquote><h2 id="函数的写法"><a href="#函数的写法" class="headerlink" title="函数的写法"></a>函数的写法</h2><pre><code>返回类型 函数名(参数1, 参数2, ... 参数n)//参数可以不写{    //函数体    ....    return 返回类型; //如果返回类型为void 可以没有return.}</code></pre><h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>每个C语言程序至少有一个函数,我们常常用main()函数, 也称之为主函数, 但是C语言的程序的主函数是不是一定叫main呢? 答案当然是否定的, 操作系统在执行main函数之前, 调用了其他代码, 这些代码就有初始化main函数所需的运行环境,而负责初始化main函数的这个函数就称之为入口函数/入口点.而入口函数规定的C程序的主函数就是main, 那么我们当然可以找到这个文件,修改主函数名.</p><h3 id="main函数的返回值"><a href="#main函数的返回值" class="headerlink" title="main函数的返回值"></a>main函数的返回值</h3><p>main函数的返回值一般有两种写法 1.<code>void main</code>2.<code>int main</code> 但是这前者最好不要使用, 不仅仅是有些编译器不支持.还因为操作系统对于一个程序的正常或者执行异常都是整型,如果程序返回 0 表示程序正常执行, 如果返回其他整型,执行异常.那么可以说<code>void main</code>就是一种不恰当的写法. int main的返回值为0或者不为0的程序的执行结果其实都一样,但为什么一定要返回0呢? 举个例子:</p><pre><code>//test.c    #include &lt;stdio.h&gt;    int main(){        printf(&quot;hello &quot;);        return 0;    }//test1.c    #include &lt;stdio.h&gt;    int main(){        printf(&quot;world!\n&quot;);        return 0;    }执行test 和 test1 &amp;&amp;运算符是指执行成功&amp;&amp;前面的便执行后面的, 如果执行前面失败,后面便不会执行.panyiwen@god:~/temp$ ./test &amp;&amp; ./test1hello world!</code></pre><p>如果我们将第一个test.c的返回值改为<code>return 1;</code>执行结果:</p><pre><code>panyiwen@god:~/temp$ ./test &amp;&amp; ./test1hello panyiwen@god:~/temp$</code></pre><p>只输出hello , 没有world和换行.也就是第二个test1.c没有执行.原因便是第一个程序的返回值是1,系统认为该程序没有执行成功.所以不会执行第二个test1</p><h3 id="main函数的三种写法-两种"><a href="#main函数的三种写法-两种" class="headerlink" title="main函数的三种写法(两种)"></a>main函数的三种写法(两种)</h3><h4 id="1-int-main-void-括号中的void可以不写"><a href="#1-int-main-void-括号中的void可以不写" class="headerlink" title="1.int main(void) //括号中的void可以不写"></a>1.int main(void) //括号中的void可以不写</h4><h4 id="2-int-main-int-argc-char-argv"><a href="#2-int-main-int-argc-char-argv" class="headerlink" title="2.int main(int argc, char *argv[])"></a>2.int main(int argc, char *argv[])</h4><h4 id="3-int-main-int-argc-char-argv-char-envp-不建议使用-因为第三个参数只是类unix系统的拓展"><a href="#3-int-main-int-argc-char-argv-char-envp-不建议使用-因为第三个参数只是类unix系统的拓展" class="headerlink" title="3.int main(int argc, char argv[], char envp[]) //不建议使用, 因为第三个参数只是类unix系统的拓展"></a>3.int main(int argc, char <em>argv[], char </em>envp[]) //不建议使用, 因为第三个参数只是类unix系统的拓展</h4><p>其实也就是main函数中可以不写参数, 写两个参数, 写三个参数. 因为是参数,所以名称可以自己取,也可以就用上述名称.</p><h4 id="三个参数"><a href="#三个参数" class="headerlink" title="三个参数"></a>三个参数</h4><ol><li><code>int argc</code> 整型参数, argc = 1+输入的参数个数, 系统自动赋值, 无需我们写, 1 为程序的名称.</li><li><code>char *argv[]</code> 字符串数组, argv[0] 表示程序的名称, argv[1]~argv[argc-1]代表我们传入的参数.</li><li><code>char *envp[]</code> 字符串数组, 表示系统的环境变量</li></ol><h4 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">    int main(int argc, char \*argv\[\], char \*envp\[\])&#123;</span><br><span class="line">        int i;</span><br><span class="line">        printf(&quot;%d\\n\\n&quot;, argc);</span><br><span class="line">        for (i = 0; i &amp;lt; argc; i++)&#123;</span><br><span class="line">            printf(&quot;%s\\n&quot;, argv\[i\]);</span><br><span class="line">        &#125;</span><br><span class="line">        printf(&quot;\\n&quot;);</span><br><span class="line">        for (i = 0; envp\[i\] != NULL; i++)&#123;</span><br><span class="line">            printf(&quot;%s\\n&quot;, envp\[i\]);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>我们执行这段程序, 并输入参数hello world, 部分输出结果, 因为系统环境变量太多.</p><pre><code>panyiwen@god:~/temp$ ./test hello world3./test hello worldXDG_VTNR=7 XDG_SESSION_ID=c2 CLUTTER_IM_MODULE=xim XDG_GREETER_DATA_DIR=/var/lib/lightdm-data/panyiwen GPG_AGENT_INFO=/home/panyiwen/.gnupg/S.gpg-agent:0:1 SHELL=/bin/bash TERM=xterm-256color ...</code></pre><p>我们可以看到, argc = 3 执行的程序名称+两个参数 argv = {“./test”, “hello”, “world”}; 而envp则全是系统环境变量key=value的字符串. 那么我们知道系统环境变量有什么用? 我们可以得到环境变量配置的一些参数来完成我们需要的功能,但是不建议推荐使用第三个参数传入,因为拓展性不强, 我们可以通过C语言的<code>#include &lt;stdlib.h&gt;</code>库中的函数来得到和设置删除系统环境变量.这样在不同系统上的使用方式就是一致的.</p><h2 id="库函数"><a href="#库函数" class="headerlink" title="库函数"></a>库函数</h2><blockquote><p>C语言库函数是把自定义函数放到库里，是别人把一些常用到的函数编完放到一个文件里，供程序员使用。程序员用的时候把它所在的文件名用#include&lt;&gt;加到里面就可以了（尖括号内填写文件名），例如<code>#include &lt;math.h&gt;</code>。</p></blockquote><p>库函数也就是一些程序员大牛们,他们将一些我们常用的函数,写到文件里面供我们调用,每次计算机语言的更新,除了一些语法的更新外,很多也是加入一些别的优秀的代码文件加入库中. 说到库函数,我们就不得不提<code>#include &lt;stdio.h&gt;</code> 我们平常写的几乎所有的C程序的开头都会加上这么一句,标准输入输出.那么我们就来介绍以下stdio.h.</p><h3 id="stdio-h"><a href="#stdio-h" class="headerlink" title="stdio.h"></a>stdio.h</h3><blockquote><p>stdio 就是指 “standard input &amp; output”（标准输入输出） 所以，源代码中如用到标准输入输出函数时，就要包含这个头文件！</p></blockquote><h5 id="引用方法-include-lt-stdio-h-gt"><a href="#引用方法-include-lt-stdio-h-gt" class="headerlink" title="引用方法: #include &lt;stdio.h&gt;"></a>引用方法: <code>#include &lt;stdio.h&gt;</code></h5><hr><blockquote><p>stdio.h所包含的函数： 文件访问: fopen,freopen,fflush,fclose 二进制输入/输出: fread, fwrite 非格式化输入/输出: fgetc/getc, fputc/putc, ungetc, fgets ,fputs 格式化输入/输出: scanf/fscanf/sscanf ,printf/fprintf/sprintf, perror 文件定位: ftell, fseek, fgetpos ,fsetpos, rewind 错误处理: feof, ferror 文件操作: remove, rename, tmpfile</p></blockquote><p>大名鼎鼎的EOF 也是宏定义在stdio.h中, 一般编译器定义是: <code>#define EOF -1</code>, 我们常用的scanf, printf 函数都是写在stdio.h中.</p><h3 id="scanf函数和printf函数"><a href="#scanf函数和printf函数" class="headerlink" title="scanf函数和printf函数:"></a>scanf函数和printf函数:</h3><blockquote><p>用 法: int scanf(char *format[,argument,…]); 用 法: int printf(“&lt;格式化字符串&gt;”, &lt;参量表&gt;);</p></blockquote><p>我们知道scanf是格式化输入, 调用此函数,我们在计算机的键盘中输入的字符串会传化为相对应的格式,储存到变量中, 并返回一个整数,代表成功输入了多少个. printf是格式化输出, 输出内容到显示器(终端) 返回值是输出字符的个数，若出错，则返回负数。 . 例子:</p><pre><code>int num = scanf(&quot;%f %d&quot;, &amp;a, &amp;b);printf(&quot;a=%f, b=%d, num = %d\n&quot;, a, b, num);</code></pre><p>分析:上面的例子,如果我们正常输入<code>11.2 2</code>,那么函数就会返回一个2表示我们输入成功输出<code>a=11.200000, b=2, num=2</code>, 如果我们输入<code>11.2 a</code>那么就会将11.2 赋值给 a, 但是’a’无法赋值给b, 输入就会失败, 输出<code>a=11.200000, b=517694128, num=1</code>b被随机赋予了一个值, 成功输入一个.如果是<code>a 11</code>那么返回值就是0了,a,b都会被随机赋值. 小知识: 我们知道一个变量是要在内存中开辟一段内存的, 变量储存的值是储存在内存中, &amp;为取地址符,我们要存值, 必须知道变量的地址. 我们平时用的a 其实是 <em>&amp;a 先取出地址再得到内存中的值, 为了方便将</em>&amp;省略. 但是如果用的多的人就会发现scanf有一些很神奇的事情发生,举几个例子:</p><pre><code>scanf(&quot;%d %lf&quot;, &amp;a, &amp;b);scanf(&quot;%s&quot;, ch);scanf(&quot;%d%c&quot;,&amp;a, &amp;c);</code></pre><p>我们对其输出, 第一个我们输入<code>11.234 12.3</code>,结果: <code>a=11 b=0.234000</code> 第二个我们输入<code>Hello World !!!</code>, 结果: <code>Hello</code> 第三个我们输入<code>16 c</code>, 结果:<code>a=16 c=&#39; &#39;</code> 我们其实明白scanf输入浮点型给整型会被强制转换, 字符串%s是不能接受空格的, 如果我们没有规定分隔符是什么,一般默认是空格, 但是输入的空格会被%c接收,所以c=’ ‘,等等很多有意思的点, 那么我们就来看看这个理由吧.先引入点知识点:</p><h3 id="stdin-stdout-stderr的简单介绍"><a href="#stdin-stdout-stderr的简单介绍" class="headerlink" title="stdin, stdout, stderr的简单介绍:"></a>stdin, stdout, stderr的简单介绍:</h3><p>1.stdin, 标准输入流: 通常是键盘输入. 2.stdout, 标准输出流: 输出到屏幕. 3.stderr, 标准错误流: 无缓冲.输出到屏幕. 一般是错误信息. 全缓冲: 直到文件结束或者手动清空缓存,才清空缓冲. 行缓冲: 遇到回车或者换行, 或者文件结束, 清空缓冲</p><blockquote><p>ISO C规定： 当且仅当stdin和stdout不指向交互式设备时，他们才是全缓冲。 stderr决不会是全缓冲。 Linux系统默认： stderr是不带缓冲的。 若流指向终端设备，则是行缓冲，否则为全缓冲。</p></blockquote><p><strong>所以在c语言中stdin和stdout是行缓冲, 我们的scanf和printf函数就是使用了stdin和stdout, 而stdin和stdout就是写在stdio中的.本质就是系统帮我们打开了两个文件句柄. 我们输入的数据就储存在stdin那个文件中, 输出的数据就存储在stdout文件中, 我们调用scanf和printf就是在文件中取数据, 进行输入和输出.</strong> 第一个例子<code>scanf(&quot;%d %lf&quot;, &amp;a, &amp;b);</code> 我们就是从缓冲区stdin 也就是字符串取出<code>11</code> 赋值给a 取出<code>.234</code>赋值给b. 所有有关这些奇特的现象就是和stdin和stdout有关. <strong>scanf 也就是 int fscanf(stdin, const char *format, [argument…]); 遇到换行或空格结束</strong> <strong>printf 也就是int fprintf( stdout, const char *format, [ argument ]…);</strong> 其他的库函数也就是大同小异,主要是知道怎么用的就好.</p><h2 id="自定义函数"><a href="#自定义函数" class="headerlink" title="自定义函数"></a>自定义函数</h2><p><strong>在库函数不满足我们的需求的时候, 我们又不想把所有代码都写在主函数里面, 那样不仅丑,而且可读性,复用性都很差.那么我们就需要自定义函数,来满足我们的需要</strong> 写法和main函数一样</p><pre><code>返回值类型 函数名(参数1, 参数2 ...)//可不写{    //函数体    ...    return 返回值;}</code></pre><p>举个例子, 比大小, 返回最大值:(虽然库函数中有)</p><pre><code>int max(int a, int b){    return a &gt; b ? a : b;   //三目运算符 等价与 if(a &gt; b) {return a;} else{ return b;}}int main(){    int a = 100, b = 120;    int maxnum;    maxnum = max(a, b); //调用max函数 返回两个数最大的那个    return 0;}</code></pre><p>C语言中需要注意的是函数要么写在执行前面, 要么是需要声明(告诉计算机有这个函数), 要不然找不到. 也就是掉个位置:</p><pre><code>int main(){    int a = 100, b = 120;    int maxnum;    int max(int, int);  //使用前需要声明有这个函数  只要使用前声明就好,也就是可以写在int main()的上面也可以.    maxnum = max(a, b); //调用max函数 返回两个数最大的那个    return 0;}int max(int a, int b){    return a &gt; b ? a : b;   //三目运算符 等价与 if(a &gt; b) {return a;} else{ return b;}}</code></pre><p>声明也就是告诉计算机,如果在这之前没找到这个函数没关系,先别报错,我的函数在下面.</p><p>友情链接:<br><a href="http://blog.csdn.net/Crazy_Tengt/article/details/72717144" target="_blank" rel="noopener">http://blog.csdn.net/Crazy_Tengt/article/details/72717144</a><br><a href="http://blog.csdn.net/q565220/article/details/49951885" target="_blank" rel="noopener">http://blog.csdn.net/q565220/article/details/49951885</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;“函数”是从英文function翻译过来的，其实，function在英文中的意思即是“函数”，也是“功能”。从本质
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言_04 三种程序结构 顺序, 选择(分支), 循环结构</title>
    <link href="https://ipanyiwen.github.io/2018/02/06/c-e8-af-ad-e8-a8-80-04-e4-b8-89-e7-a7-8d-e7-a8-8b-e5-ba-8f-e7-bb-93-e6-9e-84-e9-a1-ba-e5-ba-8f-e9-80-89-e6-8b-a9-e5-88-86-e6-94-af-e5-be-aa-e7-8e-af-e7-bb-93-e6-9e-84/"/>
    <id>https://ipanyiwen.github.io/2018/02/06/c-e8-af-ad-e8-a8-80-04-e4-b8-89-e7-a7-8d-e7-a8-8b-e5-ba-8f-e7-bb-93-e6-9e-84-e9-a1-ba-e5-ba-8f-e9-80-89-e6-8b-a9-e5-88-86-e6-94-af-e5-be-aa-e7-8e-af-e7-bb-93-e6-9e-84/</id>
    <published>2018-02-06T10:31:48.000Z</published>
    <updated>2018-07-02T06:25:01.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构；</p><p>顺序结构，从头到尾一句接着一句的执行下来，直到执行完最后一句；</p><p>选择结构，到某个节点后，会根据一次判断的结果来决定之后向哪一个分支方向执行；</p><p>循环结构，循环结构有一个循环体，循环体里是一段代码。对于循环结构来说，关键在于根据判断的结果，来决定循环体执行多少次。C语言循环控制语句是一个基于C语言的编程语句，该语句主要有while循环语句、do-while循环语句和for循环语句来实现循环结构。</p><p>但是三种结构并不是彼此孤立 循环中可以有顺序, 选择(分支).  顺序中可以有选择,可以有循环. 选择中也可以有顺序有循环. 一段程序代码往往是这三者相互结合组成的.</p><h2 id="1-顺序结构"><a href="#1-顺序结构" class="headerlink" title="1.顺序结构"></a>1.顺序结构</h2><p> C语言的顺序结构顾名思义, 就是程序自上而下执行, 没有分支,也没有循环.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int a = 3, b = 2;</span><br><span class="line">    int sum = a+b;</span><br><span class="line">    printf(&quot;a+b=%d\\n&quot;, sum);    //输出a+b的和</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>像上述代码, 程序顺序执行求和a+b并输出, 没有循环也没有分支, 所以上述代码就是一个顺序结构.</p><p><img src="/wordpress/wp-content/uploads/2018/02/20180206015153_85801.png" alt=""></p><h2 id="2-选择-分支-结构"><a href="#2-选择-分支-结构" class="headerlink" title="2.选择(分支)结构"></a>2.选择(分支)结构</h2><p>C语言选择结构用于判断给定的条件，根据判断的结果来控制程序的流程。</p><p>在C语言中, 选择结构有两种: 1. if-else语句,  2. switch-case语句;</p><h3 id="1-if-else-语句"><a href="#1-if-else-语句" class="headerlink" title="1) if-else 语句"></a>1) if-else 语句</h3><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">if(条件1)&#123;</span><br><span class="line">    //满足条件1执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;else if(条件2)&#123;</span><br><span class="line">    //不满足条件1, 满足条件2执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    //即不满足条件1也不满足条件2 执行此代码块</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>举个栗子, 成绩评级.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int score = 78; //模拟输入成绩</span><br><span class="line"></span><br><span class="line">    if (score &gt;= 90)&#123;  //成绩 大于90 A</span><br><span class="line">        printf(&quot;A&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 80 &amp;&amp; score &lt; 90)&#123; // 80-89 B</span><br><span class="line">        printf(&quot;B&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 70 &amp;&amp; score &lt; 80)&#123; // 70-79 C</span><br><span class="line">        printf(&quot;C&quot;);</span><br><span class="line">    &#125;else if(score &gt;= 60 &amp;&amp; score &lt; 70)&#123; // 60-69 D</span><br><span class="line">        printf(&quot;D&quot;);</span><br><span class="line">    &#125;else&#123;  //小于60 E</span><br><span class="line">        printf(&quot;E&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>else if 可以有0个或多个,  else 只能有0个或1个.</p><p>如果我们只需判断学生是否及各, 那么我们就可以这样写:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (score &gt;= 60)&#123;</span><br><span class="line">    printf(&quot;及格&quot;);</span><br><span class="line">&#125;else&#123;</span><br><span class="line">    printf(&quot;不及格&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然也可以只有if() 没有else ,  只有if() 和 if else()没有else.</p><h3 id="2-switch-case-语句"><a href="#2-switch-case-语句" class="headerlink" title="2)switch-case 语句"></a>2)switch-case 语句</h3><p>在C语言中, 第二种分支结构就是switch-case, 只是用的地方不太多, 因为if语句可以轻松替代switch语句, 只是结构上没switch那么清晰.</p><p>语法:  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (变量或表达式)&#123;</span><br><span class="line">    case 常量表达式1: 语句块1; break;</span><br><span class="line">    case 常量表达式2: 语句块2; break;</span><br><span class="line">    ......</span><br><span class="line">    case 常量表达式n: 语句块n; break;</span><br><span class="line">    default: 语句块n+1; break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>还是成绩评级的栗子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int score = 78;  //模拟输入</span><br><span class="line">    </span><br><span class="line">    switch(score / 10)&#123; //case匹配的数据就是score/10的结果  </span><br><span class="line">        case 10: </span><br><span class="line">        case 9: printf(&quot;A&quot;); break;</span><br><span class="line">        case 8: printf(&quot;B&quot;); break;</span><br><span class="line">        case 7: printf(&quot;C&quot;); break;</span><br><span class="line">        case 6: printf(&quot;D&quot;); break;</span><br><span class="line">        default: printf(&quot;E&quot;); break;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>score/10 得到的整数就是那个阶段的成绩, 我们会发现case 10: 也就是100分匹配后面没有任何的操作, 最主要的是, 没有break;</p><p>在switch语句中, 如果case匹配到了语句, 那么后面的语句都会执行知道出现第一个break, 或者执行完成.</p><p>如果我们将上面代码中的break全部去掉.score还是78, 那么输出就会变成 CDE, 也就是匹配到7 然后输出7之后的所有语句,知道碰到break;</p><p>default相当于else, 其他所有不匹配的情况, 因为一般是放在最下面, 所以default后面的break可以不写.</p><p><strong>重点</strong>:switch的条件只能是整型和字符型(其实就是字符的ascii码)或者这些类型的表达式,case匹配的只能是整型或者字符型常量或者这两个类型的常量表达式, 也就是case不能匹配变量.</p><h2 id="3-循环结构"><a href="#3-循环结构" class="headerlink" title="3.循环结构"></a>3.循环结构</h2><p>循环结构是指在程序中需要反复执行某个功能而设置的一种程序结构。它由循环体中的条件，判断继续执行某个功能还是退出循环。</p><p>在C语言中有三种循环结构: for循环, while循环, do-while循环.</p><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1) for循环"></a>1) for循环</h3><p>写法:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for(表达式1; 表达式2; 表达式3)&#123;</span><br><span class="line">    循环体;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>语句1：初值表达式，常用于在循环开始前为循环变量赋初值<br>语句2：循环控制逻辑表达式，控制循环执行和结束的条件<br>语句3：循环变量修改表达式，常用于修改循环变量,使得结果趋向于循环结束条件.</p><p>举个栗子:</p><p>循环输出10个”hello world!!!”</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int i;</span><br><span class="line">    for (i = 1; i &lt;= 10; i++)&#123; //循环10次, i++为 i自增长1</span><br><span class="line">        printf(&quot;hello world!!!\\n&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上诉for循环的执行过程:</p><p>1.执行表达式1, i = 1, 只执行一遍.</p><p>2. 执行表达式2, 判断 i &lt;=10</p><p>3.如果表达式2成立, 执行循环体  { printf(“hello world!!!\n”); } 否则执行退出循环, 后续步骤都不执行.</p><p>4.执行完成循环体后,执行表达式3, i++, i的值自动增长1. 回到步骤2去判断.</p><p>for循环中的三个表达式都可以为空, 但是一定要写两个分号也就是 for( ; ; ) 这样就代表无限循环, 也就是死循环.不过一般不会这样用.</p><p>而for循环常用的是对数组的操作,所以初始值一般是0.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">int Stu\[10\] = &#123;99, 87, 76, 59, 73, 45, 99, 39, 88, 19&#125;; //班级10个学生的成绩</span><br><span class="line"></span><br><span class="line">for(i = 0; i &lt; 10; i++)&#123;    //循环10次, 0~9</span><br><span class="line">    printf(&quot;学号为:%d, 成绩为: %d\\n&quot;, i+1, Stu\[i\]);   //数组下标从0开始</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实可以发现, 正常的for循环可以很清晰的明白for循环的循环次数.</p><p>所以在你很清晰明白这次循环需要循环多少次的时候推荐使用for循环.</p><h3 id="2-while-循环"><a href="#2-while-循环" class="headerlink" title="2)  while 循环"></a><strong>2)  while 循环</strong></h3><p>while循环的语法简单易懂</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">while(表达式)&#123;</span><br><span class="line">       语句块</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>执行过程: 执行表达式, 如果成立执行语句块, 否则退出循环.</p><p>while循环也可以和for循环互换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">//for -&gt; while</span><br><span class="line">int i = 0;</span><br><span class="line">while (i &lt; 10)&#123;</span><br><span class="line">    //循环体</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br><span class="line">//while -&gt; for</span><br><span class="line">for (;l &lt; r;)&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>for-&gt;while: 没有for循环那么清晰明了的知道循环次数.</p><p>while-&gt;for: 没有while循环那么简单易懂了.  </p><p>所以while循环的一般用法是我们不太清楚循环在什么时候结束, 并且我们也不关心具体的循环次数的时候使用.  </p><p>举个例子: 二分查找</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt; </span><br><span class="line"> </span><br><span class="line">int main()&#123;  </span><br><span class="line">    int a\[10\] = &#123;12, 32, 34, 55, 76, 89, 99, 123, 345, 1234&#125;; //递增的数组 </span><br><span class="line">    int l = 0, r = 9, mid; </span><br><span class="line">    int res = 345;  //查找的目标 </span><br><span class="line">    //二分查找位置 </span><br><span class="line">    while(l &lt;= r)&#123; </span><br><span class="line">        mid = (l+r)/2; </span><br><span class="line">        if (res == a\[mid\])&#123;  //找到了输出位置, 并退出循环. </span><br><span class="line">            printf(&quot;位置: %d\\n&quot;, mid+1); break; </span><br><span class="line">        &#125;else if(res &lt; a\[mid\])&#123;  </span><br><span class="line">            r = mid-1; </span><br><span class="line">        &#125;else&#123;   </span><br><span class="line">            l = mid+1; </span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    return 0; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们只看while循环的内容, while(l&lt;=r)  也就是当l&gt;r时循环退出.  </p><p>和for循环不同的是, 我们并不清楚程序在什么时候会退出, l和r在循环中是在不断变换的.这种情况使用while循环是个不错的选择.</p><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3) do-while循环"></a><strong>3) do-while循环</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">do&#123;</span><br><span class="line">    循环体</span><br><span class="line">&#125;while(表达式);</span><br></pre></td></tr></table></figure><p>和while循环不同的是,do-while循环是先执行一遍循环体,再判断是否满足表达式.</p><p>注意: do-while循环最后是有一个分号结尾的.</p><p>do-while循环的用处也就在先执行一遍循环体再判断, 那么如果我们需要判断的内容必须要执行一遍循环体才能知道的话,那么就可以使用do-while循环.</p><p>举个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    int t;</span><br><span class="line">    int res = 89;</span><br><span class="line">    do&#123;</span><br><span class="line">        printf(&quot;请输入一个数字,输入0退出游戏:&quot;);</span><br><span class="line">        scanf(&quot;%d&quot;, &amp;t);</span><br><span class="line">        if(t == res)&#123;</span><br><span class="line">            printf(&quot;猜对了!\\n&quot;);</span><br><span class="line">        &#125;else if (t &gt; res)&#123;</span><br><span class="line">            printf(&quot;太大\\n&quot;);</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            printf(&quot;太小\\n&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;while(t != 0);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这个例子bug很多, 但是我们可以清晰的理解do-while循环的不同, 我们一开始并不清楚t的值, 当我们执行完循环体后才知道t的值,然后做判断.</p><p>三大循环总结:</p><p>for 循环: 在你很清晰明白这次循环需要循环多少次的时候推荐使用.</p><p>while循环: 在我们不太清楚循环在什么时候结束, 并且我们也不关心具体的循环次数的时候推荐使用.  </p><p>do-while循环: 如果我们需要判断的内容必须要执行一遍循环体才能知道的话推荐使用.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h2&gt;&lt;p&gt;在C语言程序中，一共有三种程序结构：顺序结构、选择结构(分支结构)、循环结构；&lt;/p&gt;
&lt;p&gt;顺序结构，从头到尾一句接着一句的执行下来，直到
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言03_构造类型  数组, 结构体, 共用体, 枚举类型介绍</title>
    <link href="https://ipanyiwen.github.io/2018/02/05/c-e8-af-ad-e8-a8-8003-e6-9e-84-e9-80-a0-e7-b1-bb-e5-9e-8b-e6-95-b0-e7-bb-84-e7-bb-93-e6-9e-84-e4-bd-93-e5-85-b1-e7-94-a8-e4-bd-93-e6-9e-9a-e4-b8-be-e7-b1-bb-e5-9e-8b-e4-bb-8b-e7-bb-8d/"/>
    <id>https://ipanyiwen.github.io/2018/02/05/c-e8-af-ad-e8-a8-8003-e6-9e-84-e9-80-a0-e7-b1-bb-e5-9e-8b-e6-95-b0-e7-bb-84-e7-bb-93-e6-9e-84-e4-bd-93-e5-85-b1-e7-94-a8-e4-bd-93-e6-9e-9a-e4-b8-be-e7-b1-bb-e5-9e-8b-e4-bb-8b-e7-bb-8d/</id>
    <published>2018-02-04T18:18:06.000Z</published>
    <updated>2018-07-02T06:24:43.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言构造类型"><a href="#C语言构造类型" class="headerlink" title="C语言构造类型:"></a>C语言构造类型:</h1><h2 id="1-C语言中构造类型分为以下四种"><a href="#1-C语言中构造类型分为以下四种" class="headerlink" title="1. C语言中构造类型分为以下四种:"></a>1. C语言中构造类型分为以下四种:</h2><ul><li><strong>数组</strong></li><li><strong>结构体</strong></li><li><strong>共用体</strong></li><li><strong>枚举类型.</strong></li></ul><h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1) 数组"></a>1) 数组</h3><p>概念:为了处理方便， 把具有相同类型的若干变量按有序的形式组织起来。这些按序排列的同类数据元素的集合称为数组 知识点: 数组的开始下标都是从0开始的. 我们需要记录一些数据类型相同的数据, 比如记录一个班每个学生的总成绩, 我们可以为每个学生创建一个变量,然后将总成绩赋值,但是这样太麻烦,代码也特别长,  这个时候就需要用到数组来记录. C语言常用的数组: 1. 整型数组:一系列的整数集合.</p><pre><code>//定义一个长度为10的整型数组.int a[10];//定义一个长度为10的整型数组,并初始化.int a[10]  = {100, 98, 99, 60, 79, 45 ,9 ,68 ,79, 80};int a[] = {100, 98, 99, 60, 79, 45 ,9 ,68 ,79, 80};</code></pre><p>根据上面的例子可以发现: <strong>数组定义的方式: 和定义普通的数据类型很相似, 但是数组后加上了一个[]并在里面写明了数组的长度.</strong> <strong>数组的初始化: 初始化数据在一对花括号中,并用逗号隔开,但是如果我们不想计算有多少个元素,可以省略中括号中数组的长度,编译器会根据我们后面花括号中的内容自动计算数组的长度.</strong> <strong>如果只是定义数组而不写后面的初始化,一定要记得不能省略中括号中的数组长度.</strong> <strong>数组的访问:   通过中括号加上下标来访问的.</strong></p><pre><code>printf(&quot;%d\n&quot;, a[0]);  //输出第0个元素a[3] = 99;  //将第4个元素 改为99.</code></pre><p>  2. 浮点数数组: 一系列的浮点数的集合.</p><pre><code>//定义一个长度为10的浮点数数组.double a[10];//定义一个长度为10的浮点数数组并初始化.double a[10] = {100, 98.62, 99.13, 60.5, 79.3, 45.1 ,9.2123, 68.23 ,79.1, 80.9};double a[] = {100, 98.62, 99.13, 60.5, 79.3, 45.1 ,9.2123, 68.23 ,79.1, 80.9};double a[10] = {1.2, 3.5};</code></pre><p>根据上面的写法我们发现, 如果我们定义了一个长度为10的数组,但是我们不在花括号中写满十个数字,那么编译器会将我们写的赋值给数组的前面几个,而后面的数组元素全部赋0,</p><pre><code>//相当于double a[10] = {1.2, 3.5, 0, 0, 0, 0, 0, 0, 0,  0 };</code></pre><p>那么我们可以断定 int a[10] = {}; 那么a[10]中全部都是0, 那么如果只是定义一些 int a[10]; 呢?我们可以来测试一下.</p><pre><code>#include &lt;stdio.h&gt;int main(){    int i, a[10]={}, b[10];    printf(&quot;int a[10] = {};的输出: &quot;);    for (i = 0; i &lt; 10; i++){        printf(&quot;%d &quot;, a[i]);    }    printf(&quot;\n&quot;);    printf(&quot;int b[10];的输出: &quot;);    for (i = 0; i &lt; 10; i++){        printf(&quot;%d &quot;, b[i]);    }    printf(&quot;\n&quot;);    return 0;}</code></pre><p>我们看看输出: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/未命名.jpg" alt=""> 我们会发现,如果是直接定义int a[10]; 的其实是系统随机的值. 知道了这个我们通常会发现一些C语言的数组代码这样写:</p><pre><code>int a[100] = {0};</code></pre><p>这个其实就是初始化一个a[100]的数组,并将里面的值全部赋值为0.在花括号中写个0是使得代码更加易懂. 3.字符数组: 定义一个字符型数组.</p><pre><code>//定义一个长度为5的字符数组char s[5];//定义一个长度为5的字符数组, 并初始化.char s[5] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;}char s[] = {&apos;a&apos;, &apos;b&apos;, &apos;c&apos;, &apos;d&apos;, &apos;e&apos;}char s[5] = &quot;abcd&quot;;char s[] = &quot;abcd&quot;;</code></pre><p>这个时候会发现为什么长度为5的字符数组用双引号里面只放四个字母,而单引号放五个. 字符串: 相当于一串字符,用来表示一些语句子类的,其实也就是另类的字符数组.</p><pre><code>char c[] =  &quot;I Love C!&quot;; //字符串char c1[] = {&apos;I&apos;, &apos; &apos;, &apos;L&apos;, &apos;o&apos;, &apos;v&apos;, &apos;e&apos;, &apos; &apos;, &apos;C&apos;, &apos;!&apos;}; //字符数组</code></pre><p>这样应该比较清楚为什么会有字符串了. 便于理解! 虽然这两个都表示同样的一句话, 但是其实是有差别的, 第一个长度是10, 第二个长度是9. 原因就在于字符串的结尾有个\0的结束符号,代表这个字符串结束了.那么为什么要这样做呢? 我们举个例子:</p><pre><code>#include &lt;stdio.h&gt;int main(){    char s[20]; //字符数组    char s1[20] = &quot;I Love C!&quot;; //字符串    //模拟我们一个一个输入:    s[0] = &apos;I&apos;;    s[1] = &apos; &apos;;    s[2] = &apos;L&apos;;    s[3] = &apos;o&apos;;    s[4] = &apos;v&apos;;    s[5] = &apos;e&apos;;    s[6] = &apos; &apos;;    s[7] = &apos;C&apos;;    s[8] = &apos;!&apos;;    printf(&quot;字符数组: %s\n&quot;, s); //%s字符串标准输出    printf(&quot;字符串: %s\n&quot;, s1);    return 0;}</code></pre><p>看看输出结果: <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/未命名-1.jpg" alt="">     有没有发现,字符数组后面多了一个很奇怪的符号? 这个并不是意外,还记得我们上面说的,如果只是定义数组,系统会自动随机给数字给数组,如果没有’\0’作为结束符号,那么系统就会一直输出到出现’\0’为止.字符串输出的后面就会出现一些奇怪的符号,在windows中最常见的就是一堆”烫烫烫”. ‘\0’就是ascii码中的0.可以修改上述代码,char s[20]={0}然后试试.绝对不会出现刚刚那样的错误. <strong>多维数组:</strong> 之前我们使用的都是一维数组, C语言提供了多维数组的使用,虽然用的情况可能不多, 但是还是需要了解一些. 假设还是一个班的学生, 我们在教室, 教室有10排, 12列, 在玩一个游戏, 要记录分, 我们可以这样记录, 第三排第五列的学生成绩为89分. 第10排第11列的学生成绩为100分. 那么我们可以使用二维数组这样定义:</p><pre><code>int Stu[10][12] = {0};  //定义一个10排12列的教室, 将所有学生的初始成绩为0Stu[2][4] = 89; //第三排第五列的学生成绩为89.数组都是以0开始的.Stu[9][10] = 100; //第10排第11列的学生成绩为100. //但是这样会不会很不方便去理解 , 其实只要用多了你眼中这些就不会太难理解.//也可以换个好理解的方式来定义, 但是这样浪费内存.不建议使用.int Stu[11][13] = {0}; //定义教室, 我们不用第0排, 第0列.Stu[3][5] = 89; //第三排第五列的学生成绩为89.数组都是以0开始的.Stu[10][11] = 100; //第10排第11列的学生成绩为100. </code></pre><p>二维数组就是这样,那么三维也是同理.使用的情况即更少了.</p><h3 id="2-结构体"><a href="#2-结构体" class="headerlink" title="2) 结构体"></a>2) 结构体</h3><p><strong>结构体: 把不同类型的数据组合成一个整体</strong> 我们想要记录一个班所有学生的成绩,为了不定义所有学生的变量,我们使用数组,但是我们当然希望记录学生的姓名,各个科目的成绩.</p><pre><code>struct Student{    int id; //学号    char name[20]; //姓名    float Math; //数学成绩    float Chinese; //语文成绩    float Engish; //英语成绩};</code></pre><p>结构体的一般用法:</p><pre><code>struct Student A;  //定义一个学生A   //模拟输入   A.id = 1;   A.name[0] = &apos;T&apos;;    //如果是输入, 可以直接输入字符串.   A.name[1] = &apos;o&apos;;   A.name[2] = &apos;m&apos;;   A.name[3] = &apos;\0&apos;;   A.Math = 99.9;   A.Chinese = 100;   A.Engish = 100;</code></pre><p>在C语言我们可以选择用结构体去存储这样一个学生的信息.但是我们要存储多个学生呢? 应该知道的, 结构体数组. 定义方法:</p><pre><code>struct Student Stu[50];  //定义50个学生的数组//还有一种是直接在结构体定义时候初始化.  就像int a = 10;struct Student{    int id; //学号    char name[20]; //姓名    float Math; //数学成绩    float Chinese; //语文成绩    float Engish; //英语成绩}Stu[50]; //初始化50个学生的数组</code></pre><p>对于结构体数组的用法和普通用法数组用法也一样.</p><pre><code>Stu[0].id = 1001;   //将0号学生的学号改为1001printf(&quot;%s\n&quot;, Stu[10].name);  //输出10号学生的姓名</code></pre><h3 id="3-共用体"><a href="#3-共用体" class="headerlink" title="3) 共用体"></a>3) 共用体</h3><p><strong>几个不同的变量共同占用一段内存的结构，在C语言中，被称作“共用体”类型结构</strong> 共用体在写法上和结构体很相似.</p><pre><code>union data{    int i;    char ch;    double d;};</code></pre><p>但是共用体相当于这三个变量共用一段地址, 我们创建变量 union data a; 那么这个a占用多少字节呢? 就是union data中字节最多 double d, 所以这个union占用了8个字节. int 为四个字节, 如果我们访问 a.i, 就会去内存中取前(或者后, 不同编译器)4个字节, 同理访问a.ch 就会去内存中去前1个字节, 如果访问a.d就会8个字节全部取出. 举个栗子:</p><pre><code>#include &lt;stdio.h&gt;union data{    int i;    char ch;    short s;};int main(){    union data a;    a.i = 97;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    //因为int 占4个字节 范围 -2147483648 ~ 2147483647    //char 占1个字节 范围 -128 ~ 127    //short 占2个字节 范围 -32768 ~ 32767    a.i = 128;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    a.i = 32768;    printf(&quot;a.i = %d, a.ch = %c, a.s=%hd\n&quot;, a.i, a.ch, a.s);    return 0;}//输出结果:a.i = 97, a.ch = a, a.s=97a.i = 128, a.ch = �, a.s=128a.i = 32768, a.ch = , a.s=-32768</code></pre><h3 id="4-枚举类型"><a href="#4-枚举类型" class="headerlink" title="4) 枚举类型"></a>4) 枚举类型</h3><p><strong>如果一个变量只有几种可能的值，则可以定义为“枚举类型”.</strong> 比如限定几种颜色, 星期一到星期天. 都可以使用枚举类型来表示. 定义</p><pre><code>enum Color{red,yellow,blue,green};</code></pre><p>用法:</p><pre><code>#include &lt;stdio.h&gt;enum Color{red,yellow,blue,green};int main(){    enum Color c;    c = red;    if (c == red){        printf(&quot;红色\n&quot;);    }    return 0;}</code></pre><p>输出就是红色. 枚举类型可以让我们更加直观的感受到这个颜色就是一种类型. 但其实每个颜色都代表着一个数字,所以我们用==判断就是比较数字.我们可以将if(c== red) 改为if(c == 0) 结果也是一样的. 当然枚举类型还能自己给每个枚举元素赋一个代表它的整数.</p><pre><code>#include &lt;stdio.h&gt;enum Color{red=2,yellow,blue,green};int main(){    printf(&quot;%d %d %d %d\n&quot;, red, yellow , blue, green);    return 0;}</code></pre><p>输出结果:</p><pre><code>2 3 4 5</code></pre><p>如果我们再改动blue = 7, 结果</p><pre><code>2 3 7 8</code></pre><p>更加可怕的是, 我们可以将enum的多个元素设置为一个值:</p><pre><code>#include &lt;stdio.h&gt;enum Color{red=2,RED=2, yellow,blue,green}; int main(){    enum Color c = red;    if(c == RED){        printf(&quot;红色!\n&quot;);    }    return 0; }</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言构造类型&quot;&gt;&lt;a href=&quot;#C语言构造类型&quot; class=&quot;headerlink&quot; title=&quot;C语言构造类型:&quot;&gt;&lt;/a&gt;C语言构造类型:&lt;/h1&gt;&lt;h2 id=&quot;1-C语言中构造类型分为以下四种&quot;&gt;&lt;a href=&quot;#1-C语言中构造类型分为以下四
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言02_基本数据类型</title>
    <link href="https://ipanyiwen.github.io/2018/02/04/c-e8-af-ad-e8-a8-8002-e5-9f-ba-e6-9c-ac-e6-95-b0-e6-8d-ae-e7-b1-bb-e5-9e-8b/"/>
    <id>https://ipanyiwen.github.io/2018/02/04/c-e8-af-ad-e8-a8-8002-e5-9f-ba-e6-9c-ac-e6-95-b0-e6-8d-ae-e7-b1-bb-e5-9e-8b/</id>
    <published>2018-02-04T04:14:25.000Z</published>
    <updated>2018-07-02T06:24:24.877Z</updated>
    
    <content type="html"><![CDATA[<h1 id="C语言的数据类型"><a href="#C语言的数据类型" class="headerlink" title=" C语言的数据类型:"></a> C语言的数据类型:</h1><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/02/Cshujuleixing.png" alt=""></p><h2 id="知识点-C语言中-unsigned-和-signed-关键字-用来修饰变量是否带符号-也就是正负-unsigned-无符号-lt-gt-变量只能是大于等于0的数-signed-有符号-lt-gt-变量可以是负数"><a href="#知识点-C语言中-unsigned-和-signed-关键字-用来修饰变量是否带符号-也就是正负-unsigned-无符号-lt-gt-变量只能是大于等于0的数-signed-有符号-lt-gt-变量可以是负数" class="headerlink" title="知识点: C语言中, unsigned 和 signed 关键字,用来修饰变量是否带符号,也就是正负. unsigned 无符号&lt;=&gt; 变量只能是大于等于0的数,  signed 有符号 &lt;=&gt; 变量可以是负数."></a>知识点: C语言中, unsigned 和 signed 关键字,用来修饰变量是否带符号,也就是正负. unsigned 无符号&lt;=&gt; 变量只能是大于等于0的数,  signed 有符号 &lt;=&gt; 变量可以是负数.</h2><p><strong>编译器的基本数据类型变量如果不声明一般默认是有符号的.</strong></p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型:"></a>基本数据类型:</h2><h3 id="1-整型-整型变量表示的是整数类型的数据-默认有符号"><a href="#1-整型-整型变量表示的是整数类型的数据-默认有符号" class="headerlink" title="1.整型: 整型变量表示的是整数类型的数据. 默认有符号."></a>1.整型: 整型变量表示的是整数类型的数据. 默认有符号.</h3><p>整数分为 正整数, 负整数, 0. 所以计算机为了表示正负,用了第一位当符号位.</p><ul><li>int  基本型, 在32位和64位系统上都占4个字节. 占用内存也就是32位,因为是二进制表示,所以2^32=4294967296,  去掉一位符号为, 0占一位, 所以范围表示: -2^31 ~ (2^31) - 1&lt;=&gt; -2147483648 ~ 2147483647.</li><li>short 短整型, 在32位和64位系统上都占2个字节. 占用内存16位&lt;=&gt;范围:-2^15 ~ (2^15) -1 &lt;=&gt; -32768~32767</li><li>long 长整型, 在32位系统上是4字节,64位系统是8字节.内存如上计算.</li><li>__int64 | long long  在VC中是__int64,在gcc中是long long, 用来表示超过了32位的整数.占用内存64位.</li></ul><h3 id="2-浮点型-浮点型变量表示的是实数类型的数据-有符号而且不能用unsigned修饰-实数类型没有无符号类型"><a href="#2-浮点型-浮点型变量表示的是实数类型的数据-有符号而且不能用unsigned修饰-实数类型没有无符号类型" class="headerlink" title="2.浮点型: 浮点型变量表示的是实数类型的数据.有符号而且不能用unsigned修饰.实数类型没有无符号类型."></a>2.浮点型: 浮点型变量表示的是实数类型的数据.有符号而且不能用unsigned修饰.实数类型没有无符号类型.</h3><ul><li>float 单精度浮点数 占4个字节, 占用内存是32位.</li><li>double 双精度浮点数 占8个字节, 占用内存64位.</li></ul><p>浮点数在计算机内用指数型式表示, 可以分解为：数符, 尾数, 指数符, 指数四部分。 数符占1位, 表示数字的正负. 指数符占1位, 表示指数的正负. 尾数表示浮点数有效数字, 即小数点后多少位. 指数存指数的有效数字. 指数占多少位, 尾数占多少位, 由计算机系统决定. 如果是数符加尾数占24位, 指数符加指数占8位 即 float. 数符加尾数占48位, 指数符加指数占16位 即 double.</p><h3 id="3-字符类型-字符变量表示的是单个字符类型的数据-默认符号是根据编译器来的"><a href="#3-字符类型-字符变量表示的是单个字符类型的数据-默认符号是根据编译器来的" class="headerlink" title="3.字符类型: 字符变量表示的是单个字符类型的数据. 默认符号是根据编译器来的."></a>3.字符类型: 字符变量表示的是单个字符类型的数据. 默认符号是根据编译器来的.</h3><ul><li>char 字符型 占1个字节, 占用内存8位.</li></ul><p>我们键盘上的26个字母加上大小写, 加特殊字符等按照从0~127编号, 这就是该字符的ascii码.所以char类型本质其实就是一位的整数.         注意: 在c语言中一个汉字是占2个字符的.所以需要字符数组来表示.这个很好理解,因为中文2^8=256个全部用来表示中文也不够.所以用两个字符表示, 2^16=65536个字符,就能表示几乎全部的中文了.但是其他的一些语言中文是用一个字符来表示,但是这些语言一个字符一般都是两个字节.<br>想要详细了解下编码方式可以参考:  <a href="http://www.welcom212.com/wordpress/?p=20" target="_blank" rel="noopener">编码方式</a> </p><p><strong>    unsigned char 和 signed char: </strong> 我们一般的编译器像 VC, GCC的默认char类型是有符号的,据说 arm-linux-gcc上的char类型是无符号的, 也就是unsigned char类型, 因为ascii码只有127个, 所以无符号和有符号的用法差别不大.</p><p>其他语言可能还有byte(字节)类型, 在c语言中可以用unsigned char 来模拟.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//写法</span><br><span class="line">int a = 1;</span><br><span class="line">double b = 1.123;</span><br><span class="line">char c = &apos;A&apos;;</span><br><span class="line">unsigned char c = 200;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;C语言的数据类型&quot;&gt;&lt;a href=&quot;#C语言的数据类型&quot; class=&quot;headerlink&quot; title=&quot; C语言的数据类型:&quot;&gt;&lt;/a&gt; C语言的数据类型:&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;http://120.78.85.68/wordpress/wp
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>C语言01_介绍+helloworld</title>
    <link href="https://ipanyiwen.github.io/2018/02/03/c-e8-af-ad-e8-a8-8001-e4-bb-8b-e7-bb-8dhelloworld/"/>
    <id>https://ipanyiwen.github.io/2018/02/03/c-e8-af-ad-e8-a8-8001-e4-bb-8b-e7-bb-8dhelloworld/</id>
    <published>2018-02-02T17:24:39.000Z</published>
    <updated>2018-07-02T03:51:23.320Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h2><p>C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。  </p><h2 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器:"></a>编辑器:</h2><p>CodeBlocks ,功能比较齐全,下载的时候务必看清是否带有编译器,一般是默认自带了MinGW. 附个:  <a href="http://www.codeblocks.org/downloads/26" target="_blank" rel="noopener">下载链接</a> windows的话, 选择文件后缀为 mingw-setup.exe的下载.</p><h2 id="例子"><a href="#例子" class="headerlink" title="例子:"></a>例子:</h2><p>一个入门的C语言程序hello world,向计算机的世界发出我们的问候.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    printf(&quot;hello world!!!\\n&quot;);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果就是在终端输出一个字符串: hello world.</p><h2 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释:"></a>代码解释:</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;stdio.h&gt;</span><br></pre></td></tr></table></figure><p>C语言引入库函数的方式, 因为后面用了标准输出函数printf.而这个方法是写在stdio.h这个标准输入输出库文件中的函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int main()&#123;&#125;</span><br></pre></td></tr></table></figure><p>C语言程序的入口点,main函数, 返回值为int ,  后面有个return 0.  这个就是返回值, 返回一个0代表正常结束.花 括号代码块, 函数后接上一对花括号,花括号里面的内容都为函数体.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf(&quot;hello world!!!\\n&quot;);</span><br></pre></td></tr></table></figure><p>标准输出函数,向终端显示一条字符串”hello world!!!”.   ‘\n’为换行,如果”123\n456”. 那么456就会显示在下一行中.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return 0;</span><br></pre></td></tr></table></figure><p>返回值,因为main函数前定义了返回值为int , 所以必须返回一个整形数字,而0一般代表正常结束,当然返回其他整数也不会报错,但是不建议这样做.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介:&quot;&gt;&lt;/a&gt;简介:&lt;/h2&gt;&lt;p&gt;C语言是一门通用计算机编程语言，应用广泛。C语言的设计目标是提供一种能以简易的方式编译、处理低级存储器、产生少量的机器码以及不需要任何运
      
    
    </summary>
    
      <category term="C语言" scheme="https://ipanyiwen.github.io/categories/C%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://ipanyiwen.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>笔记：jsp的九大内置对象和四大作用域</title>
    <link href="https://ipanyiwen.github.io/2018/01/29/e7-ac-94-e8-ae-b0-ef-bc-9ajsp-e7-9a-84-e4-b9-9d-e5-a4-a7-e5-86-85-e7-bd-ae-e5-af-b9-e8-b1-a1-e5-92-8c-e5-9b-9b-e5-a4-a7-e4-bd-9c-e7-94-a8-e5-9f-9f/"/>
    <id>https://ipanyiwen.github.io/2018/01/29/e7-ac-94-e8-ae-b0-ef-bc-9ajsp-e7-9a-84-e4-b9-9d-e5-a4-a7-e5-86-85-e7-bd-ae-e5-af-b9-e8-b1-a1-e5-92-8c-e5-9b-9b-e5-a4-a7-e4-bd-9c-e7-94-a8-e5-9f-9f/</id>
    <published>2018-01-29T14:15:12.000Z</published>
    <updated>2018-07-02T06:27:26.997Z</updated>
    
    <content type="html"><![CDATA[<p>知识点: 一个jsp页面的本质其实就是一个servlet。重写了Service方法。 tomcat服务器将jsp自动生成servlet的代码存放位置就在tomcat安装目录下的work中。 我的是在：C:\Program Files\Apache Software Foundation\Tomcat 9.0\work\Catalina\localhost\myPro\org\apache\jsp 创建一个 test.jsp页面 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171332.png" alt=""> </p><p>服务器自动生成的servlet代码:</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171216.png" alt=""> </p><p>jsp由Java代码和HTML代码组成，在生成的servlet中HTML代码是由 javax.servlet.jsp.JspWriter的对象out.write(“<html>…</html>“)写的。这个对象JspWriter正好是jsp的九大内置对象之一的out。</p><h1 id="九大内置对象："><a href="#九大内置对象：" class="headerlink" title="九大内置对象："></a><strong>九大内置对象：</strong></h1><p>内置对象： jsp也就是servlet自动创建了九个对象。 page、config、request、response、session、application、out、exception、pageContext exception对象默认不会创建，request和response对象作为参数传入。所以将test.jsp 生成的servlet打开可以看到剩下的6个内置对象的定义。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128171945.png" alt=""></p><h2 id="1-page对象"><a href="#1-page对象" class="headerlink" title="1.page对象"></a><strong>1.page对象</strong></h2><p>根据定义我们可以发现page对象的创建：final java.lang.Object page = this; 也就是page的本身就是servlet类本身（this）。</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128173036.png" alt=""> </p><p>我们可以在jsp打印this和page的地址会发现是指向同一个地址，但是一些方法却被隐藏起来了。 page变量属于pageContext域， 也就是作用范围是当前jsp页面。这很容易理解了。当前page就是当前这个servlet的this指针。当然不能到其他页面。当然刷新页面相当于重新访问servlet，所以page也就重新刷新。之前储存的内容当然也就清空了。</p><h2 id="2-config对象"><a href="#2-config对象" class="headerlink" title="2.config对象"></a><strong>2.config对象</strong></h2><p>web容器在初始化时使用一个ServletConfig(即config)对象向JSP页面传递信息，此配置信息包括初始化参数（在当前Web应用的应用部署描述文件web.xml中定义）以及表示Servlet或JSP页面所属Web应用的ServletContext对象。 也就是说config对象可以将web.xml配置信息传递到jsp页面。但是jsp初始化配置信息情况比较少，但是对于servlet的使用的情况较多。用法: web.xml配置：</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128220550-e1517151181611.png" alt=""> </p><p>servlet写法：</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180128220515.png" alt=""> </p><p>我们可以在web.xml配置数据库的账号密码。然后再servlet中得到这个账号密码。当然还能得到一些其他的配置信息。 所以conf对象当然属于pageContext域，作用范围也固然是当前页面。</p><h2 id="3-request对象"><a href="#3-request对象" class="headerlink" title="3. request对象"></a>3. request对象</h2><p>根据servlet中会发现，request对象并没有在servlet中定义，request对象是作为参数传递过来的。其实request对象是在客户端(浏览器)发送一次请求，服务器(tomcat)自动帮我们将请求的消息封装进request中，生成request对象传给servlet。所以request对象包含了客户端发起请求的所有信息。 request对象的作用是与客户端交互，收集客户端的Form、Cookies、超链接，或者收集服务器端的环境变量。 <strong>request对象的常用方法:</strong></p><ul><li>String getParameter(String name),获取客户端的参数值，常用于表单</li><li>String[] getParameterValues(String name),获取单个参数的所有值，常用语表单中的多选</li><li>Enumeration getPameterName(),获取所有的参数的名称</li><li>void setCharacterEncoding(String encoding),设置字符编码方式</li><li>Cookie[ ] getCookies(),得到所有的Cookies</li></ul><p>当然request还可以得到和设置请求头所有信息。 request还有一个很重要的作用：请求转发。</p><ul><li>request.getRequestDispatcher(“url”).forward(request, response);</li><li>request.getRequestDispatcher(“url”).include(request, response);</li></ul><p>因为可以转发，request对象可以存放数据， 用法：request.setAttribute(str, Object); 在转发的jsp页面中取数据：Object = request.getAttribute(str);   forward 和 include 的实质： 我们在servlet中分别用forward和include请求转发跳转页面。用out输出一些内容到网页中，并打印request对象和response对象的地址。然后在跳转的页面输出request对象和response对象的地址。</p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129152359.png" alt=""> </p><p>不论是forward还是include会发现地址不同，也就是jsp页面中的request，forward和servlet中的不是同一个request。但是却可以得到信息，所以应当是拷贝了一份request过去。 forward转发会发现，不论是转发前的“hhhh”还是转发后的“h1111hhh”，都不会在test.jsp的页面中输出。而include却会输出。 我们查看两者的jsp页面的源码便可发现，其实include其实是将servlet所代表的jsp页面和转发的jsp页面合并。所以如果前一个只是单纯的servlet页面，并无jsp。那么include就可以输出一些东西到转发的jsp页面中，但是include并不常用。 也就是response并不会传递，只是两个页面合并后才能用转发前页面的response对象的getWriter。 因此：请求转发只能转发到同一web项目的资源。客户浏览器只做了一次请求，服务器完成请求处理并转发请求，页面跳转。所以url地址不会变化，仍然是客户端（浏览器）的第一次请求的URL。 请求转发，不改变url地址，会跳转界面，还会将request对象的信息传递过去，直到请求结束，才会销毁request对象。 所以request对象属于request域，在请求结束后才会真正销毁。虽然每个页面都会新建一个request对象，但是对于请求转发来说，request会完全复制过去，也就相当于request对象并未消失。所以属于request域。刷新页面相当于重新发送请求，所以request对象会重新创建，之前的信息丢失。</p><h2 id="4-response对象"><a href="#4-response对象" class="headerlink" title="4. response对象"></a><strong>4. response对象</strong></h2><p>Response对象用于动态响应客户端请示，控制发送给用户的信息，并将动态生成响应。Response对象只提供了一个数据集合cookie，它用于在客户端写入cookie值。若指定的cookie不存在，则创建它。若存在，则将自动进行更新。结果返回给客户端浏览器。 response最重要的就是响应页面。所以response最重要的也就是得到和设置响应头的信息 常用方法：</p><blockquote><ul><li>String setCharacterEncoding()//设置响应字符编码格式</li><li>String getCharacterEncoding()//获取响应字符编码格式</li><li>void setContentType(String type)//设置响应MIME类型</li><li>sendRedirect(java.lang.String location)//请求重定向</li><li>PrintWriter getWriter()//获取打印输出对象</li></ul></blockquote><p>response可以响应界面并给浏览器添加cookie 用法：response.addCookie(cookie); response还有一个很重要的功能，重定向： 用法：response.sendRedirect(location); 重定向也可以跳转界面，但是与请求转发不同的是重定向并不能传递request,地址栏上的url也会发生变化，而且能够访问其他web项目的资源。 本质：客户端(浏览器)发送了两次请求。客户端(浏览器)发送第一次请求，服务器接受处理，response返回一个状态码302  (3xx状态码重定向到其他地方: 需要客户端再次发送请求),客户端(浏览器)接收，发现是302，于是又发送了一条请求，请求的url便是重定向的参数location，服务器接收请求处理并跳转页面。 因为是客户端（浏览器）发送的请求，所以自然可以访问其他web项目。地址栏也自然会发生变化。 因此，response其实是pageContext域的属性，在访问jsp或者servlet时服务器自动创建，但是在有关请求转发或者重定向时，都没有拷贝过去，所以response是自然是属于pageContext域。</p><h2 id="5-session对象"><a href="#5-session对象" class="headerlink" title="5. session对象"></a><strong>5. session对象</strong></h2><p>Session:在计算机中，尤其是在网络应用中，称为“会话控制”。Session 对象存储特定用户会话所需的属性及配置信息。这样，当用户在应用程序的 Web 页之间跳转时，存储在 Session 对象中的变量将不会丢失，而是在整个用户会话中一直存在下去。 session实现的两种机制： 1. cookie, 服务器没生成一个session对象存储信息，每个session对象都有一个sessionid， 响应客户端（浏览器）生成一个cookie，存放sessionid，服务器会读取cookie中的sessionid来检索到以前的session对象。 2.重写url，上述方法在浏览器禁用cookie的话无法实现，所以我们在每个访问的url后加上sessionid也同样能做到。 得到session的一种方式： HttpSession session = request.getSession(); 为session设值： session.setAttribute(“usrid”, userid); 取值： userid = session.getAttribute(“usrid”); session的生存周期，session会在客户端关闭，或者超过设定时间时自动销毁，默认为30分钟。 设值时间的一种方式，也可以在xml配置文件，或者tomcat中配置。 session.setMaxInactiveInterval(900);  //在60*15 = 900， 15分钟后销毁 故，session属于session域。生存周期为时间到，或者浏览器关闭，自动销毁。</p><h2 id="6-application对象"><a href="#6-application对象" class="headerlink" title="6.application对象"></a><strong>6.application对象</strong></h2><p>application对象的使用方法和session很类似，但是不同的是application的生存周期是在web项目删除或者服务器关闭才会销毁。 原理： 在服务器端创建的对象，储存在服务器端的内容中。所以客户端的一切行为都不会影响到application对象。 所以application属于application域，作用范围在整个web项目。</p><h2 id="7-out对象"><a href="#7-out对象" class="headerlink" title="7. out对象"></a><strong>7. out对象</strong></h2><p>作用向页面输出内容， out对象被封装为javax.servlet.jsp.jspWriter接口，通过调用pageContext.getOut()方法可以获取out对象。 out对象是字符流对象，其作用和用法与ServletResponse.getWriter()方法返回的PrintWriter对象十分类似。都可以向页面输出信息，但是有所不同，那就是PrintWriter输出的内容一般都会在out对象输出内容的前面，给个例子: </p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129200636.png" alt=""> </p><p>访问该页面，得到结果： </p><p><img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129200734-300x183.png" alt=""> </p><p>但是也可以按照我们希望的顺序输出，那就是在out输出完后加一个方法 out.flush();顺序就是我们的代码顺序了。 原理： PrintWriter 有一个缓冲区， 当我们用printwriter对象输出页面的内容会全部到缓冲区中，然后输出到页面。而JSPWriter也有这么一个缓冲区，当缓冲区满了就会输出到PrintWriter的缓冲区。然后再一起输出到页面。 刚刚的代码也就是。</p><ol><li>printwriter.write(“&lt;h1&gt;PrintWriter1&lt;/h1&gt;”);   “PrintWriter1”进入PrintWriter的缓冲区。</li><li>out.write(“&lt;h1&gt;JSPWriter&lt;/h1&gt;”);  “JSPWriter”进入JSPWriter的缓冲区。</li><li>printwriter.write(“&lt;h1&gt;PrintWriter2&lt;/h1&gt;”);   “PrintWriter2”进入PrintWriter的缓冲区。</li><li>结束，JSPWriter缓冲区的内容写到PrintWriter的缓冲区中。</li><li>所以PrintWriter的缓冲区变成”PrintWriter1” “PrintWriter2” “JSPWriter”;</li></ol><p>可以用out.getBufferSize()查看缓冲区的大小，我的默认是8192。 out.flush 函数就是讲out缓冲区的内容直接输出到PrintWriter缓冲区中。 一些函数： 1.public abstract void clear() 清除缓冲区中的内容，不将数据发送至客户端。 2.public abstract void clearBuffer() 将数据发送至客户端后，清除缓冲区中的内容。 3.public abstarct void close() 关闭输出流。 4.public abstract void flush() 输出缓冲区中的数据。 5.public int getBufferSize() 获取缓冲区的大小。缓冲区的大小可用&lt;%@ page buffer=”size” %&gt;设置。 6.public abstract int getRemainning() 获取缓冲区剩余空间的大小 7.public boolean isAutoFlush() 获取用&lt;%@ page is AutoFlush=”true/false”%&gt;设置的AutoFlush值。 8.public abstract void newLine() 输出一个换行字符，换一行。 9.public abstract void print() 显示各种数据类型的内容。 10.public abstract void println() 分行显示各种数据类型的内容。 <img src="http://slist.cnblogs.com/aggbug/242334.html" alt=""> 所以out对象为pageContext域。</p><h2 id="8-exception对象"><a href="#8-exception对象" class="headerlink" title="8. exception对象"></a><strong>8. exception对象</strong></h2><p>使用它，必须结合page指令中的isErrorPage属性和errorPage属性。都是在头部定义。如果定义了errorPage=”error.jsp”那么就会抛出异常跳转到error.jsp页面，而不会直接弹出500错误。如果定义了isErrorPage=”true”，就说明这个页面就是能够接受异常的错误界面。 _jspx_page_context对异常的处理也非常简单：如果该页面的page指令指定了errorPage属性，则将请求forward到errorPage属性指定的页面，否则使用系统页面来输出异常信息。但是该页没有内置exception对象。 errorPage页面则定义了exception对象，定义如下：</p><p>java.lang.Throwable exception = org.apache.jasper.runtime.JspRuntimeLibrary.getThrowable(request);</p><p>也就是forward中的request请求带来了exception的信息。所以exception对象只存在error.jsp页面中，不会到其他页面。所以exception作用域：pageContext 举个栗子： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205300.png" alt=""> <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205250.png" alt=""> 运行结果： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180129205344.png" alt=""></p><h2 id="9-pageContext对象"><a href="#9-pageContext对象" class="headerlink" title="9. pageContext对象"></a><strong>9. pageContext对象</strong></h2><p>JSP页面的管理者(上下文)，它能获得其他八个内置对象。得到四个作用域常量。 1、获得其它八大内置对象 getXxx()c</p><ul><li>pageContext.getOut();　　//获得out对象</li><li>pageContext.getApplication();　　//获得application对象</li><li>pageContext.getRequest();       //获得request对象。</li><li>……  //获得其他内置对象</li></ul><p>2、 提供作用域常量 scope, 其实就是int类型，分别为1、2、3、4。封装起来代表四种类型。</p><ul><li>PageContext.PAGE_SCOPE　　page</li><li>PageContext.REQUEST_SCOPE　　request</li><li>PageContext.SESSION_SCOPE　　response</li><li>PageContext.APPLICATION_SCOPE　　application</li></ul><p>3、为各个域存值和取值</p><ul><li>　pageContext.getAttribute(name [, scope]);　　//获得scope作用域数据</li><li>pageContext.setAttribute(name,value [, scope]);　//给scope作用域设置内容</li><li>　pageContext.removeAttribute(name [, scope]);　　//给scope作用域移除内容</li></ul><p>scope就是上面的四种作用域常量 。 一次获得指定名称内容 4、findAttribute(name);　//依次从page、request、session、application 获得内容。 所以pageContext对象也是pageContext域。它只在本身页面范围有效。</p><h1 id="四大作用域"><a href="#四大作用域" class="headerlink" title="四大作用域:"></a><strong>四大作用域:</strong></h1><p>pageContext  &lt;  request  &lt;  session &lt; application, pageContext 域:   范围页面本身。 request 域：   范围一次请求。 session域:  范围在设定时间内整个浏览器，只要浏览器不关闭，都有效。 application域:  范围整个服务器运行。只要项目没被移除，或者服务器没重启或关闭，那么application都存在。</p><p>参考链接，致谢：</p><p><a href="https://www.cnblogs.com/whgk/p/6427759.html" target="_blank" rel="noopener">https://www.cnblogs.com/whgk/p/6427759.html</a> </p><p><a href="http://blog.csdn.net/meiyalei/article/details/2129120" target="_blank" rel="noopener">http://blog.csdn.net/meiyalei/article/details/2129120</a> </p><p><a href="https://www.cnblogs.com/fjdingsd/p/4918748.html" target="_blank" rel="noopener">https://www.cnblogs.com/fjdingsd/p/4918748.html</a></p><p><a href="http://blog.csdn.net/qq_34342083/article/details/53944941" target="_blank" rel="noopener">http://blog.csdn.net/qq_34342083/article/details/53944941</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;知识点: 一个jsp页面的本质其实就是一个servlet。重写了Service方法。 tomcat服务器将jsp自动生成servlet的代码存放位置就在tomcat安装目录下的work中。 我的是在：C:\Program Files\Apache Software Foun
      
    
    </summary>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="jsp" scheme="https://ipanyiwen.github.io/tags/jsp/"/>
    
      <category term="九大内置对象" scheme="https://ipanyiwen.github.io/tags/%E4%B9%9D%E5%A4%A7%E5%86%85%E7%BD%AE%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>互联网协议-简单理解和介绍</title>
    <link href="https://ipanyiwen.github.io/2018/01/27/e4-ba-92-e8-81-94-e7-bd-91-e5-8d-8f-e8-ae-ae-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3-e5-92-8c-e4-bb-8b-e7-bb-8d/"/>
    <id>https://ipanyiwen.github.io/2018/01/27/e4-ba-92-e8-81-94-e7-bd-91-e5-8d-8f-e8-ae-ae-e7-ae-80-e5-8d-95-e7-90-86-e8-a7-a3-e5-92-8c-e4-bb-8b-e7-bb-8d/</id>
    <published>2018-01-27T08:45:37.000Z</published>
    <updated>2018-07-02T06:26:45.924Z</updated>
    
    <content type="html"><![CDATA[<h1 id="概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。"><a href="#概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。" class="headerlink" title="概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。"></a><strong>概念</strong>：互联网实现过程中大家都需要遵循的准则，我们称之为协议。</h1><p>前提概要： 我们知道当我们访问互联网是，是在浏览器的导航栏输入一个网址，<a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a> 而一个网址对应的是一个ip地址，所以我们访问网址，那么就很清楚的认识到访问网址，就是访问另外一个ip地址的计算机上储存的网页。那么我们已知的只有计算机的ip，我们就根据这个来了解一下互联网的世界是如何做到的查找到另外的计算机的。</p><h1 id="一、-五层模型。"><a href="#一、-五层模型。" class="headerlink" title="一、 五层模型。"></a><strong>一、 五层模型。</strong></h1><p>互联网的模型有7层模型， 4层模型的说法，5层模型是结合这两种更加利于理解的一种说法。5层模型从上往下分别是：应用层，传输层，网络层，数据链路层，物理层。（名词可能会有点出入，翻译问题） <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/7bf4e8201ee0799d2770a37ed41232eb.png" alt=""></p><h2 id="1-物理层"><a href="#1-物理层" class="headerlink" title="1.物理层"></a><strong>1.物理层</strong></h2><p>物理层就是最底层的电路之间的传输，不同的电脑与电脑之间相互通过网线，WiFi等，构建起了整个互联网的基础。</p><h2 id="2-数据链路层"><a href="#2-数据链路层" class="headerlink" title="2.数据链路层"></a><strong>2.数据链路层</strong></h2><p>互联网的电脑数不胜数，我们两台电脑之间怎么相互连接，传递数据呢？首先就需要将电脑相互区分——MAC地址，然后传递数据需要单位吧，不然一堆0101传递过去计算机接受了也无法识别那部分属于什么应用程序的，当时不同得企业选择不同的单位，不同的风格，然后渐渐统一，出现了互联网的一个重要协议 ——以太网协议， 规定数据单位为：帧。</p><h3 id="2-1-MAC地址"><a href="#2-1-MAC地址" class="headerlink" title="2.1 MAC地址"></a><strong>2.1 MAC地址</strong></h3><p>链接网络需要网卡，每台计算机的网卡地址就是MAC地址，每块网卡出厂的MAC地址独一无二。这样每台计算机就有了个独一无二的身份了。</p><h3 id="2-2-以太网协议"><a href="#2-2-以太网协议" class="headerlink" title="2.2 以太网协议"></a><strong>2.2 以太网协议</strong></h3><p>以太网协议规定了网络数据传输过去的单位是一帧， 两台计算机之间的MAC地址也必须储存在帧中，所以一帧又分为标头(Head)和数据(Data)两部分。 标头(Head)存放两台计算机的MAC地址， 数据部分(Data)存放需要传输的数据。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052904.png" alt=""></p><h3 id="2-3-广播"><a href="#2-3-广播" class="headerlink" title="2.3 广播"></a><strong>2.3 广播</strong></h3><p>现在发送方知道了接收方是谁，也就是网络IP（域名），数据也写成帧的形式，那么怎么确定在众多电脑中哪台是接收方呢？以太网的方式非常简单——广播，给所有的计算机都发送数据，让其他计算机自己判断，其他计算机接受到了数据，判断是不是自己，不对就将其抛弃，对就将自己的MAC地址发送回去。具体的实现——ARP协议（在网络层介绍）</p><h2 id="3-网络层"><a href="#3-网络层" class="headerlink" title="3.网络层"></a><strong>3.网络层</strong></h2><p>广播技术理论上是能成立的。但是互联网的众多计算机中，用广播的方式给每台计算机发送一个数据包明显不现实。但是我们又需要知道对方计算机的MAC地址传输数据。那么就需要缩小范围，如果是在同一子网中的计算机，用广播的方式就能够实现。所以网络层提出了一个新的概念——IP。</p><h3 id="3-1-IP协议"><a href="#3-1-IP协议" class="headerlink" title="3.1 IP协议"></a><strong>3.1 IP协议</strong></h3><p>每台计算机分配一个ip地址，目前广泛使用的是第四版，称为IPV4。由32位二进制组成，为了方便理解，我们分为四段十进制数从0.0.0.0到255.255.255.255，假设前24位为网络部分，后8位为主机部分。假设我们有一个ip地址为：192.168.0.123，那么192.168.0.*  ， 都为同一子网。该子网最多为2^8=256台， 如何确定多少位是网络多少位是主机呢？——子网掩码。</p><h3 id="3-2-子网掩码"><a href="#3-2-子网掩码" class="headerlink" title="3.2 子网掩码"></a><strong>3.2 子网掩码</strong></h3><p>1&amp;1 = 1, 1&amp;0=0, 0&amp;0 = 0。 假设24位为网络部分，那么子网掩码为:1111 1111. 1111 1111.1111 1111.0000 0000 = 255.255.255.0, ip1 和ip2 两个ip是否在同一子网呢？ ip1 &amp; 子网掩码 == ip2&amp; 子网掩码，那么就是在同一子网。192.168.0.123&amp;255.255.225.0 = 192.168.0.0。</p><h3 id="3-3-网关-gateway-和ARP协议"><a href="#3-3-网关-gateway-和ARP协议" class="headerlink" title="3.3  网关(gateway)和ARP协议"></a><strong>3.3  网关(gateway)和ARP协议</strong></h3><p>我们已知ip地址，那么就会碰到两种情况： 1.不在同一子网: 发送方将数据交给自己的网关，网关再去找到接受方ip的网关，然后就是在同一子网的情况了。 2.在同一子网:根据ARP协议，用广播的方式发送给接收方，接收方回应后得到接收方的MAC地址。 网关：网关实质上是一个网络通向其他网络的IP地址，有兴趣可以去查看一下DHCP服务器的实现原理。给一张百度的图片来理解： <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/8ad4b31c8701a18be9fc814f9e2f07082838fe9f.jpg" alt=""> ARP协议：地址解析协议，即ARP（Address Resolution Protocol），是根据IP地址获取MAC地址的一个TCP/IP协议。主机发送信息时将包含目标IP地址的ARP请求广播到该子网的网络上的所有主机，所有主机确认该IP是否是自己本身，不是则抛弃该信息，是的话接收返回自身的MAC地址，以此确定目标的物理地址。</p><h3 id="3-4-IP数据包"><a href="#3-4-IP数据包" class="headerlink" title="3.4  IP数据包"></a><strong>3.4  IP数据包</strong></h3><p>根据以太网协议，数据包的单位为：帧： head+data， head中存放了MAC地址，但是我们又需要ip地址才能查找到。所以我们将数据部分继续拆分为head+data。head中存放ip地址。所以一帧数据变成了：head+head+data。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052910.png" alt=""></p><h2 id="4-传输层"><a href="#4-传输层" class="headerlink" title="4  传输层"></a><strong>4  传输层</strong></h2><p>我们已经知道ip和mac地址，我们可以准确的找到我们需要发送数据的那台计算机，但是计算机接受了数据怎么判断数据是交给哪个应用的呢？网上听歌和看电影那么传送过来的数据是歌曲应用的还是电影应用的呢？ ——端口。</p><h3 id="4-1-端口："><a href="#4-1-端口：" class="headerlink" title="4.1 端口："></a><strong>4.1 端口：</strong></h3><p>计算机可以选择0到65535个端口，正好16个二进制位。0到1023的端口被系统占用，用户程序可以在1024~65535端口之间选择一个。用户计算机端口与服务器计算机端口相连接，然后就可以传输数据了。</p><h3 id="4-2-UDP、-TCP-协议"><a href="#4-2-UDP、-TCP-协议" class="headerlink" title="4.2 UDP、**TCP**协议"></a><strong>4.2 UDP、**</strong>TCP<strong>**协议</strong></h3><p>如你所料，端口号当然也是要保存到数据包中，所以就有了UDP协议和TCP协议。UDP和TCP协议也同样继续将data分为head和data。head中存放端口号信息。 UDP协议：几乎就是简单的将端口号放入head中，数据没有安全保障，也容易丢包，但是传输速度非常快。比较适合语音，视频这类数据传播。 TCP协议：比较安全的将一些信息放入head中，通过协议不会丢包，通过三次握手保证信息的安全。是比较安全的一种协议。但是因为安全所以传输速度较慢。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052912.png" alt=""> 这时候一帧数据就变成了上面这样。 了解了上面的内容也许就能对ip地址有了一定的了解了，下面的图片应该看得懂了，DNS是将域名转化为IP地址一台服务器计算机。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/TIM图片20180127161219.png" alt=""></p><h2 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5.应用层"></a><strong>5.应用层</strong></h2><p>不同的应用需要的数据都是不同的，向FTP传输数据格式，和邮件传输通过SMTP格式。应用层就是这些数据格式的协议组成的。为用户提供各种服务。 <img src="http://120.78.85.68/wordpress/wp-content/uploads/2018/01/bg2012052913.png" alt=""></p><h1 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h1><p>物理层：构成互联网基础，使得所有计算机能够物理连接在一起。 数据链路层：以太网协议，数据分为帧传递。Head存放计算机的MAC地址 网络层：IP协议，数据再次细分，Head存放计算机的ip地址 传输层：TCP或UDP协议，数据再细分， 确定数据端口。Head存放了端口号。 应用层：处理数据，为应用提供服务，使得用户能够明白和使用。</p><h1 id="我的简单理解："><a href="#我的简单理解：" class="headerlink" title="我的简单理解："></a><strong>我的简单理解：</strong></h1><p>我的IP为192.168.0.111 ——&gt;浏览器访问 <a href="http://www.baidu.com/" target="_blank" rel="noopener">http://www.baidu.com/</a>  , 通过域名解析(DNS)为 115.239.211.112， 通过子网掩码255.255.255.0 发现我的IP和百度的IP不在同一子网，所以本机发送一个数据包【（本机MAC地址，不知百度MAC地址），（本机的IP地址， 百度的IP地址）（TCP请求的端口）（请求正文）】的请求提交给网关(gateway)，网关去找到115.239.211.112。然后百度的服务器返回一个MAC地址。通过tcp协议三次握手建立连接。 致谢：<a href="http://www.ruanyifeng.com/blog/2012/05/internet_protocol_suite_part_i.html" target="_blank" rel="noopener">阮一峰的网络日志</a> 以上内容参考至阮一峰网络日志，需要更加详细了解可以去看看。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot;&gt;&lt;a href=&quot;#概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot; class=&quot;headerlink&quot; title=&quot;概念：互联网实现过程中大家都需要遵循的准则，我们称之为协议。&quot;&gt;
      
    
    </summary>
    
      <category term="网络" scheme="https://ipanyiwen.github.io/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="协议" scheme="https://ipanyiwen.github.io/tags/%E5%8D%8F%E8%AE%AE/"/>
    
  </entry>
  
  <entry>
    <title>笔记: AJAX</title>
    <link href="https://ipanyiwen.github.io/2018/01/25/e7-ac-94-e8-ae-b0-ajax/"/>
    <id>https://ipanyiwen.github.io/2018/01/25/e7-ac-94-e8-ae-b0-ajax/</id>
    <published>2018-01-25T08:11:05.000Z</published>
    <updated>2018-07-02T06:28:16.950Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概念："><a href="#概念：" class="headerlink" title="概念："></a><strong>概念：</strong></h2><p>AJAX = Asynchronous JavaScript and XML（异步的 JavaScript 和 XML）。 AJAX 不是新的编程语言，而是一种使用现有标准的新方法。 AJAX 最大的优点是在不重新加载整个页面的情况下，可以与服务器交换数据并更新部分网页内容。 AJAX 不需要任何浏览器插件，但需要用户允许JavaScript在浏览器上执行。 <strong>Question：</strong> 当注册一个网页的时候，填写完用户名，文本框刚刚失去焦点，马上提示该用户已经被注册。这肯定是访问了后台，但是页面也没有刷新呀。一般是用了AJAX。不重新加载整个页面的情况下与服务器进行交互。 <strong>语法：</strong> <strong>1. JavaScript：</strong></p><pre><code>function getInfo(){    var xmlhttp;    if (window.XMLHttpRequest){            // IE7+, Firefox, Chrome, Opera, Safari 浏览器执行代码        xmlhttp=new XMLHttpRequest();    }else{    // IE6, IE5 浏览器执行代码        xmlhttp=new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;);    }    xmlhttp.onreadystatechange=function(){        if (xmlhttp.readyState==4 &amp;&amp; xmlhttp.status==200){                 var str = xmlhttp.responseText;                 alter(str);        }    }    xmlhttp.open(&quot;GET&quot;,&quot;/url&quot;,true);    xmlhttp.send();}</code></pre><p>代码解释：(以Java为例！) 首先是执行最下面的xmlhttp.open();之后发送给服务器处理，处理完成后执行<code>onreadystatechange=function(){}</code> ，在其中操作。 xmlhttp.open()的三个参数分别是：执行get/post方法，访问的URL地址， 是否为异步请求。 第一个参数： GET，<code>xmlhttp.open(&quot;GET&quot;,&quot;/url&quot;,true);</code>  向服务器发送数据就只能在URL中带过去，/url?data=123; POST ，<code>xmlhttp.open(&quot;POST&quot;,&quot;/url&quot;,true);</code> 向服务器发送数据方法，<code>需要设置一下请求头, setRequestHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;); //`</code>以form表单的形式提交，后台就可以像接受form表单数据一样接受数据。  xmlhttp.send(“data=123”);<code>再向服务器发送数据。 第二个参数: /url    访问服务器的servlet。 第三个参数: true 为异步操作，方法写在</code>onreadystatechange=function(){}<code>中。 false为同步操作, 方法直接写在send的后面，不需要</code>onreadystatechange<code>解释：</code>xmlhttp.readyState==4` readyState从 0 到 4 发生变化。</p><ul><li>0: 请求未初始化</li><li>1: 服务器连接已建立</li><li>2: 请求已接收</li><li>3: 请求处理中</li><li>4: 请求已完成，且响应已就绪</li></ul><p>status为访问状态，404 页面没找到， 500 内部错误， 200访问正常等。</p><ul><li>1xx  -消息: 请求正在处理，请稍后。。。</li><li>2xx -成功处理</li><li>3xx -重定向到其他地方: 需要客户端再次发送请求</li><li>4xx -客户端错误，eg: 非法的资源请求，禁止访问</li><li>5xx -服务器段错误 ，eg: 服务器抛出异常</li></ul><p>在Java中将处理结果的字符串，一般是以JSON字符串返回，存储在前端xmlhttp.responseText中。 <strong>2.  jQuery写法：</strong> jquery将上述写法进行了封装，使得我们更加简单和方便的去使用ajax。常见用法：</p><p>$.ajax(function(){<br>    type: “post”,<br>    url : “url”,<br>    data: {“name”:”Peter”},<br>    success:function(data, status){<br>       //处理<br>    },<br>    error:function(){<br>        //error有三个参数，可以依据情况需要写<br>    }<br>});</p><p>jquery还专门封装了$.get() 和 $.post()的ajax用法，分别执行get和post。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概念：&quot;&gt;&lt;a href=&quot;#概念：&quot; class=&quot;headerlink&quot; title=&quot;概念：&quot;&gt;&lt;/a&gt;&lt;strong&gt;概念：&lt;/strong&gt;&lt;/h2&gt;&lt;p&gt;AJAX = Asynchronous JavaScript and XML（异步的 JavaSc
      
    
    </summary>
    
      <category term="JavaScript|JQuery" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/"/>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="ajax" scheme="https://ipanyiwen.github.io/tags/ajax/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript笔记: JSON</title>
    <link href="https://ipanyiwen.github.io/2018/01/25/javascript-e7-ac-94-e8-ae-b0-json/"/>
    <id>https://ipanyiwen.github.io/2018/01/25/javascript-e7-ac-94-e8-ae-b0-json/</id>
    <published>2018-01-25T07:05:15.000Z</published>
    <updated>2018-07-02T00:38:39.202Z</updated>
    
    <content type="html"><![CDATA[<p><strong>概念：</strong> JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。 <strong>语法：</strong> JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同小异，键/值对组合中的键名写在前面并用双引号 “” 包裹，使用冒号 : 分隔，然后紧接着值。</p><p>{“key”:value}<br>等价于JavaScript的<br>{key : value}</p><p><strong>重点：</strong> <strong>JSON 是 JS 对象的字符串表示法，它使用文本表示一个 JS 对象的信息，本质是一个字符串。</strong> <strong>JSON 语法非常简单, 简单记住三种: {} 和 [] 和 :</strong> <strong>一对大括号, 代表一个对象, {id : 1, name:’xiaoming’}</strong> <strong>一对中括号, 代表一个数组, [{id : 1, name:’xiaoming’}, {id : 2, name:’xiaohong’}]</strong> <strong>  冒号,  冒号前是key, 后是value.</strong> JSON与JS对象之间的转化方式：</p><p>要实现从对象转换为 JSON 字符串，使用 JSON.stringify() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  var json = JSON.stringify(&#123;a: </span><br><span class="line">&apos;Hello&apos;</span><br><span class="line">, b: </span><br><span class="line">&apos;World&apos;</span><br><span class="line">&#125;); </span><br><span class="line">  结果：&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;</span><br></pre></td></tr></table></figure><p>要实现从 JSON 转换为对象，使用 JSON.parse() 方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  var obj = JSON.parse(</span><br><span class="line">&apos;&#123;&quot;a&quot;: &quot;Hello&quot;, &quot;b&quot;: &quot;World&quot;&#125;&apos;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">  结果： &#123;a: &apos;Hello&apos;, b: &apos;World&apos;&#125;</span><br></pre></td></tr></table></figure><p><strong>JSON 数组：</strong></p><p>写在方括号中,{key : [value1_key : value, value2_key : value, …]}</p><p>{<br>“employees”: [<br>{ “firstName”:”John” , “lastName”:”Doe” },<br>{ “firstName”:”Anna” , “lastName”:”Smith” },<br>{ “firstName”:”Peter” , “lastName”:”Jones” }<br>]<br>}</p><p>因为json是一个字符串，所以传输起来比较快。解析起来也方便，web中常常用的到。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;概念：&lt;/strong&gt; JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。 &lt;strong&gt;语法：&lt;/strong&gt; JSON 键值对是用来保存 JS 对象的一种方式，和 JS 对象的写法也大同
      
    
    </summary>
    
      <category term="JavaScript|JQuery" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/"/>
    
      <category term="编程笔记" scheme="https://ipanyiwen.github.io/categories/JavaScript-JQuery/%E7%BC%96%E7%A8%8B%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="json" scheme="https://ipanyiwen.github.io/tags/json/"/>
    
  </entry>
  
  <entry>
    <title>Goodbye 2017</title>
    <link href="https://ipanyiwen.github.io/2017/12/31/goodbye-2017/"/>
    <id>https://ipanyiwen.github.io/2017/12/31/goodbye-2017/</id>
    <published>2017-12-30T16:55:21.000Z</published>
    <updated>2018-07-02T07:28:12.587Z</updated>
    
    <content type="html"><![CDATA[<p>GoodBye2017,新的一年马上就要到来!!!</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;GoodBye2017,新的一年马上就要到来!!!&lt;/p&gt;

      
    
    </summary>
    
      <category term="未分类" scheme="https://ipanyiwen.github.io/categories/%E6%9C%AA%E5%88%86%E7%B1%BB/"/>
    
    
  </entry>
  
</feed>
